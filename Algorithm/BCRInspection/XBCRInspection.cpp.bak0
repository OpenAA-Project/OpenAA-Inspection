#include "BCRInspectionResource.h"
#include "swap.h"
#include "XBCRInspection.h"
#include "DTKBarReader.h"
#include "DTKImage.h"
#include "fftw3.h"
#include "XCriticalFunc.h"


//==================================================================================

BCRInspectionThreshold::BCRInspectionThreshold(BCRInspectionItem *parent) 
	: AlgorithmThreshold(parent)
{
	CheckType	=0;
	QuilityGrade=10;
}
	
void	BCRInspectionThreshold::CopyFrom(const AlgorithmThreshold &src)
{
	const BCRInspectionThreshold	*s=dynamic_cast<const BCRInspectionThreshold *>(&src);
	CheckType	=s->CheckType;
	QuilityGrade=s->QuilityGrade;
	GradeList	=s->GradeList;
}
	
bool	BCRInspectionThreshold::IsEqual(const AlgorithmThreshold &src)
{
	const BCRInspectionThreshold	*s=dynamic_cast<const BCRInspectionThreshold *>(&src);
	if(CheckType	==s->CheckType
	&& QuilityGrade	==s->QuilityGrade
	&& GradeList	==s->GradeList){
		return true;
	}
	return false;
}
	
bool	BCRInspectionThreshold::Save(QIODevice *f)
{
	if(::Save(f,CheckType	)==false)	return false;
	if(::Save(f,QuilityGrade)==false)	return false;
	if(GradeList.Save(f)	==false)	return false;
	return true;
}
	
bool	BCRInspectionThreshold::Load(QIODevice *f)
{
	if(::Load(f,CheckType	)==false)	return false;
	if(::Load(f,QuilityGrade)==false)	return false;
	if(GradeList.Load(f)	==false)	return false;
	return true;
}
	
BCRInspectionItem::BCRInspectionItem(void)
{	
	BCRType=0;
	AVector=NULL;

	for(int i=0;i<4;i++){
		FFT_in[i]	=NULL;
		FFT_out[i]	=NULL;
		FFTLen[i]	=0;
		FPlan[i]	=NULL;
	}
}

BCRInspectionItem::~BCRInspectionItem(void)
{
	for(int i=0;i<4;i++){
		if(FFT_in[i]!=NULL)
			fftw_free(FFT_in[i]);
		if(FFT_out[i]!=NULL)
			fftw_free(FFT_out[i]);

		if(FPlan[i]!=NULL){
			fftw_free(FPlan[i]);
		}

		FFT_in[i]	=NULL;
		FFT_out[i]	=NULL;
		FFTLen[i]	=0;
		FPlan[i]	=NULL;
	}
}


ExeResult	BCRInspectionItem::ExecuteInitialAfterEdit	(int ExeID ,int ThreadNo
														,ResultInItemRoot *Res
														,ExecuteInitialAfterEditInfo &EInfo)
{
	int	cx,cy;
	GetCenter(cx,cy);
	AVector=(AlignmentPacket2D *)GetAlignmentPointer(cx,cy);
	if(AVector!=NULL)
		AVector->Set(this);

	int	x1,y1,x2,y2;
	GetArea().GetXY(x1,y1,x2,y2);

	FFTLen[0]=y2-y1;
	FFTLen[1]=x2-x1;
	FFTLen[2]=hypot(x2-x1,y2-y1);
	FFTLen[3]=hypot(x2-x1,y2-y1);

	for(int i=0;i<4;i++){
		if(FFT_in[i]!=NULL)
			fftw_free(FFT_in[i]);
		if(FFT_out[i]!=NULL)
			fftw_free(FFT_out[i]);

		FFT_in[i]	=(fftw_complex*)fftw_malloc( sizeof(fftw_complex)*FFTLen[i] );
		FFT_out[i]	=(fftw_complex*)fftw_malloc( sizeof(fftw_complex)*FFTLen[i] );

		FPlan[i]=fftw_plan_dft_1d( FFTLen[i], FFT_in[i], FFT_out[i], FFTW_FORWARD, FFTW_ESTIMATE );
	}

	return _ER_true;
}

ExeResult	BCRInspectionItem::ExecuteProcessing		(int ExeID ,int ThreadNo,ResultInItemRoot *Res)
{
	ImagePointerContainer ImageList;
	GetTargetBuffList(ImageList);

	const	BCRInspectionThreshold	*H=GetThresholdR();
	if(H->CheckType==0){
		Calc(ImageList);
		ResultInspection	*R=Res->GetResultInspection();
		if(R!=NULL){
			R->SetInspectionBarcode(Result);
		}
	}
	if(H->CheckType==true){
		CheckQuality(ImageList,Res);
	}

	return _ER_true;
}

void	BCRInspectionItem::DrawResultItem(ResultInItemRoot &Res,QImage &IData ,QPainter &PData ,int MovX ,int MovY ,double ZoomRate,bool OnlyNG)
{
	if(GetThresholdR()->CheckType==1){
		QColor	c=Qt::red;
		c.setAlpha(100);
		GetArea().Draw(Res.GetTotalShiftedX(),Res.GetTotalShiftedY(),&IData ,c.rgba()
						,ZoomRate ,MovX ,MovY);

		int	Cx,Cy;
		GetArea().GetCenter(Cx,Cy);
		int	X=(Cx+MovX)*ZoomRate;
		int	Y=(Cy+MovY)*ZoomRate;
		PData.drawText(X,Y,QString("Quarily: ")
						  +QString::number(Res.GetResultDouble(),'f',3));
		ResultPosList	*R=Res.GetPosListFirst();
		if(R!=NULL){
			PData.drawText(X,Y+16,QString("Grade: ")
								 +R->Message);
		}
	}
	else{
		QColor	c=Qt::yellow;
		c.setAlpha(60);
		GetArea().Draw(Res.GetTotalShiftedX(),Res.GetTotalShiftedY(),&IData ,c.rgba()
						,ZoomRate ,MovX ,MovY);
	}
}
void	BCRInspectionItem::CopyThresholdOnly(BCRInspectionItem *src)
{
	GetThresholdW()->CheckType		=src->GetThresholdR(GetLayersBase())->CheckType;
	GetThresholdW()->QuilityGrade	=src->GetThresholdR(GetLayersBase())->QuilityGrade;
	GetThresholdW()->GradeList		=src->GetThresholdR(GetLayersBase())->GradeList;
}

bool	BCRInspectionItem::Calc(ImagePointerContainer &ImageList)
{
	Result=/**/"";
	BCRInspectionBase		*ABase=(BCRInspectionBase *)GetParentBase();
	if(ABase!=NULL){
		int	W=GetArea().GetWidth();
		int	H=GetArea().GetHeight();

		int	IdealSize=ABase->IdealSize;
		double	Wz=(double)W/(double)IdealSize;
		double	Hz=(double)H/(double)IdealSize;
		double	Z=min(Wz,Hz);
		if(Z<1.0)
			Z=1.0;
		double	ZoomRate=1.0/Z;
	
		try{
			QImage	Img(W*ZoomRate,H*ZoomRate,QImage::Format_RGB32);
			MakeImage(Img,ZoomRate,GetLayerNumb(),0,ImageList);
			Img.save(/**/"TmpBCR.bmp",/**/"BMP");
		}
		catch(...){}

		ABase->GetBCR(/**/"TmpBCR.bmp",Result);

		if(Result.isEmpty()==true && GetLayerNumb()>1){
			for(int L=0;L<GetLayerNumb();L++){
				QImage	Img(W*ZoomRate,H*ZoomRate,QImage::Format_RGB32);
				MakeImage(Img,ZoomRate,1,L,ImageList);
				Img.save(/**/"TmpBCRR.bmp",/**/"BMP");
				ABase->GetBCR(/**/"TmpBCRR.bmp",Result);
				if(Result.isEmpty()==false)
					break;
				RMakeImage(Img,ZoomRate,1,L,ImageList);
				Img.save(/**/"TmpBCRR.bmp",/**/"BMP");
				ABase->GetBCR(/**/"TmpBCRR.bmp",Result);
				if(Result.isEmpty()==false)
					break;
			}
		}
	}

	return true;
}

void	BCRInspectionItem::MakeImage(QImage &Img ,double ZoomRate ,int LayerNumb,int LNo,ImagePointerContainer &ImageList)
{
	int	W=Img.width();
	int	H=Img.height();
	double	Z=1.0/ZoomRate;

	int		mx=0;
	int		my=0;
	if(AVector!=NULL){
		mx=AVector->ShiftX;
		my=AVector->ShiftY;
	}
	else{
		AlignmentPacket2D	V;
		int	cx,cy;
		GetCenter(cx,cy);
		V.PosXOnTarget=cx;
		V.PosYOnTarget=cy;
		V.ShiftX=0;
		V.ShiftY=0;
		GetAlignmentForProcessing(V);
		mx=V.ShiftX;
		my=V.ShiftY;
	}

	int	MinX=GetArea().GetMinX()+mx;
	int	MinY=GetArea().GetMinY()+my;
	BCRInspectionBase		*ABase=(BCRInspectionBase *)GetParentBase();
	if(ABase==NULL){
		if(LayerNumb>=3){
			ImageBuffer *hR=ImageList[0];
			ImageBuffer *hG=ImageList[1];
			ImageBuffer *hB=ImageList[2];
			for(int y=0;y<H;y++){
				int	Y=y*Z;
				BYTE	*dest=Img.scanLine(y);
				BYTE	*sR=hR->GetY(MinY+Y);
				BYTE	*sG=hG->GetY(MinY+Y);
				BYTE	*sB=hB->GetY(MinY+Y);
				for(int x=0;x<W;x++){
					int	X=x*Z;
					*(dest+0)=sR[MinX+X];
					*(dest+1)=sG[MinX+X];
					*(dest+2)=sB[MinX+X];
					*(dest+3)=0xFF;
					dest+=4;
				}
			}
		}
		else if(LayerNumb>=2){
			ImageBuffer *hR=ImageList[0];
			ImageBuffer *hG=ImageList[1];
			for(int y=0;y<H;y++){
				int	Y=y*Z;
				BYTE	*dest=Img.scanLine(y);
				BYTE	*sR=hR->GetY(MinY+Y);
				BYTE	*sG=hG->GetY(MinY+Y);
				for(int x=0;x<W;x++){
					int	X=x*Z;
					*(dest+0)=sR[MinX+X];
					*(dest+1)=sG[MinX+X];
					*(dest+2)=0;
					*(dest+3)=0xFF;
					dest+=4;
				}
			}
		}
		else if(LayerNumb>=1){
			ImageBuffer *hR=ImageList[LNo];
			for(int y=0;y<H;y++){
				int	Y=y*Z;
				BYTE	*dest=Img.scanLine(y);
				BYTE	*sR=hR->GetY(MinY+Y);
				for(int x=0;x<W;x++){
					int	X=x*Z;
					*(dest+0)=sR[MinX+X];
					*(dest+1)=sR[MinX+X];
					*(dest+2)=sR[MinX+X];
					*(dest+3)=0xFF;
					dest+=4;
				}
			}
		}
	}
	else{
		ImageBuffer *hR=ImageList[ABase->AdotpedLayer];
		for(int y=0;y<H;y++){
			int	Y=y*Z;
			BYTE	*dest=Img.scanLine(y);
			BYTE	*sR=hR->GetY(MinY+Y);
			for(int x=0;x<W;x++){
				int	X=x*Z;
				*(dest+0)=sR[MinX+X];
				*(dest+1)=sR[MinX+X];
				*(dest+2)=sR[MinX+X];
				*(dest+3)=0xFF;
				dest+=4;
			}
		}
	}
}

static	int	Clip255(int n,int d)
{
	if(n<0)	return d-20;
	else	return d+20;
}

void	BCRInspectionItem::RMakeImage(QImage &Img ,double ZoomRate ,int LayerNumb,int LNo,ImagePointerContainer &ImageList)
{
	BCRInspectionBase		*ABase=(BCRInspectionBase *)GetParentBase();
	int	OffAdd=ABase->FixedValue;
	//int	W=GetArea().GetWidth();
	//int	H=GetArea().GetHeight();
	int	W=Img.width();
	int	H=Img.height();
	int		mx=0;
	int		my=0;
	if(AVector!=NULL){
		mx=AVector->ShiftX;
		my=AVector->ShiftY;
	}
	else{
		AlignmentPacket2D	V;
		int	cx,cy;
		GetCenter(cx,cy);
		V.PosXOnTarget=cx;
		V.PosYOnTarget=cy;
		V.ShiftX=0;
		V.ShiftY=0;
		GetAlignmentForProcessing(V);
		mx=V.ShiftX;
		my=V.ShiftY;
	}
	int	MinX=GetArea().GetMinX()+mx;
	int	MinY=GetArea().GetMinY()+my;
	double	Z=1.0/ZoomRate;

	if(LayerNumb>=3){
		ImageBuffer *hR=ImageList[0];
		ImageBuffer *hG=ImageList[1];
		ImageBuffer *hB=ImageList[2];
		for(int y=0;y<H;y++){
			int	Y=y*Z;
			BYTE	*dest=Img.scanLine(y);
			BYTE	*sR=hR->GetY(MinY+Y);
			BYTE	*sG=hG->GetY(MinY+Y);
			BYTE	*sB=hB->GetY(MinY+Y);
			for(int x=0;x<W;x++){
				int	X=x*Z;
				*(dest+0)=255-sR[MinX+X];
				*(dest+1)=255-sG[MinX+X];
				*(dest+2)=255-sB[MinX+X];
				*(dest+3)=0xFF;
				dest+=4;
			}
		}
	}
	else if(LayerNumb>=2){
		ImageBuffer *hR=ImageList[0];
		ImageBuffer *hG=ImageList[1];
		for(int y=0;y<H;y++){
			int	Y=y*Z;
			BYTE	*dest=Img.scanLine(y);
			BYTE	*sR=hR->GetY(MinY+Y);
			BYTE	*sG=hG->GetY(MinY+Y);
			for(int x=0;x<W;x++){
				int	X=x*Z;
				*(dest+0)=255-sR[MinX+X];
				*(dest+1)=255-sG[MinX+X];
				*(dest+2)=0;
				*(dest+3)=0xFF;
				dest+=4;
			}
		}
	}
	else if(LayerNumb>=1){
		ImageBuffer *hR=ImageList[0];
		ImageBuffer *hB=ImageList[2];
		for(int y=0;y<H;y++){
			int	Y=y*Z;
			BYTE	*dest=Img.scanLine(y);
			BYTE	*sR=hR->GetY(MinY+Y);
			BYTE	*sB=hB->GetY(MinY+Y);
			for(int x=0;x<W;x++){
				int	X=x*Z;
				*(dest+0)=Clip255(sR[MinX+X]-sB[MinX+X],OffAdd);
				*(dest+1)=Clip255(sR[MinX+X]-sB[MinX+X],OffAdd);
				*(dest+2)=Clip255(sR[MinX+X]-sB[MinX+X],OffAdd);
				*(dest+3)=0xFF;
				dest+=4;
			}
		}
	}
}

QString	BCRInspectionItem::OutputResult(ResultPosList *p)
{
	return QString(/**/"BCR=")+Result;
}

void	BCRInspectionItem::MoveForAlignment(void)
{
	int		mx=0;
	int		my=0;
	if(AVector!=NULL){
		mx=AVector->ShiftX;
		my=AVector->ShiftY;
	}
	else{
		AlignmentPacket2D	V;
		int	cx,cy;
		GetCenter(cx,cy);
		V.PosXOnTarget=cx;
		V.PosYOnTarget=cy;
		V.ShiftX=0;
		V.ShiftY=0;
		GetAlignmentForProcessing(V);
		mx=V.ShiftX;
		my=V.ShiftY;
	}
	MoveTo(mx,my);
}

//=================================================================

void	BCRInspectionInPage::TransmitDirectly(GUIDirectMessage *packet)
{
	CmdReqBCodeList	*CmdReqBCodeListVar=dynamic_cast<CmdReqBCodeList *>(packet);
	if(CmdReqBCodeListVar!=NULL){
		for(AlgorithmItemPI *a=GetFirstData();a!=NULL;a=a->GetNext()){
			BCRInspectionItem	*Item=dynamic_cast<BCRInspectionItem *>(a);
			if(Item!=NULL){
				BCRList	*k=new BCRList();
				k->LocalPage	=GetPage();
				k->ItemID		=Item->GetID();
				Item->GetXY(k->X1,k->Y1,k->X2,k->Y2);
				k->BCRType		=Item->BCRType;
				k->CheckType	=Item->GetThresholdR()->CheckType;
				CmdReqBCodeListVar->Container->AppendList(k);
			}
		}
		return;
	}
	CmdReqBCodeTest	*CmdReqBCodeTestVar=dynamic_cast<CmdReqBCodeTest *>(packet);
	if(CmdReqBCodeTestVar!=NULL){
		AlgorithmItemRoot	*a=SearchIDItem(CmdReqBCodeTestVar->ItemID);
		if(a!=NULL){
			BCRInspectionItem	*Item=dynamic_cast<BCRInspectionItem *>(a);
			if(Item!=NULL){
				if(CmdReqBCodeTestVar->Mastered==true){
					ImagePointerContainer ImageList;
					Item->GetMasterBuffList(ImageList);
					Item->Calc(ImageList);
					CmdReqBCodeTestVar->Result=Item->Result;
				}
				else{
					ImagePointerContainer ImageList;
					Item->GetTargetBuffList(ImageList);
					Item->Calc(ImageList);
					CmdReqBCodeTestVar->Result=Item->Result;
				}
			}
		}
		return;
	}
	AddBCRInspectionAreaPacket	*AddBCRInspectionAreaVar=dynamic_cast<AddBCRInspectionAreaPacket *>(packet);
	if(AddBCRInspectionAreaVar!=NULL){
		BCRInspectionItem	*Item=new BCRInspectionItem();
		Item->SetArea(AddBCRInspectionAreaVar->Area);
		Item->BCRType=AddBCRInspectionAreaVar->BCRType;
		Item->GetThresholdW()->CheckType	=AddBCRInspectionAreaVar->CheckType;
		Item->GetThresholdW()->QuilityGrade	=AddBCRInspectionAreaVar->QuilityGrade;
		Item->GetThresholdW()->GradeList	=AddBCRInspectionAreaVar->GradeList;
		AppendItem(Item);
		return;
	}
	CmdReqBCodeResults	*CmdReqBCodeResultsVar=dynamic_cast<CmdReqBCodeResults *>(packet);
	if(CmdReqBCodeResultsVar!=NULL){
		for(AlgorithmItemPI *a=GetFirstData();a!=NULL;a=a->GetNext()){
			BCRInspectionItem	*Item=dynamic_cast<BCRInspectionItem *>(a);
			if(Item!=NULL){
				CmdReqBCodeResultsVar->ResultBarcode.append(Item->Result);
			}
		}
		return;
	}
	CmdSetBCodeResults	*CmdSetBCodeResultsVar=dynamic_cast<CmdSetBCodeResults *>(packet);
	if(CmdSetBCodeResultsVar!=NULL){
		for(AlgorithmItemPI *a=GetFirstData();a!=NULL;a=a->GetNext()){
			BCRInspectionItem	*Item=dynamic_cast<BCRInspectionItem *>(a);
			if(Item!=NULL){
				Item->Result=CmdSetBCodeResultsVar->ResultBarcode;
				CmdSetBCodeResultsVar->OK=true;
			}
		}
		return;
	}
	CmdReqBCodeInfoByItem	*CmdReqBCodeInfoByItemVar=dynamic_cast<CmdReqBCodeInfoByItem *>(packet);
	if(CmdReqBCodeInfoByItemVar!=NULL){
		AlgorithmItemRoot	*a=SearchIDItem(CmdReqBCodeInfoByItemVar->ItemID);
		if(a!=NULL){
			BCRInspectionItem	*Item=dynamic_cast<BCRInspectionItem *>(a);
			if(Item!=NULL){
				const	BCRInspectionThreshold	*Thr=Item->GetThresholdR();

				CmdReqBCodeInfoByItemVar->CheckType		=Thr->CheckType		;
				CmdReqBCodeInfoByItemVar->QuilityGrade	=Thr->QuilityGrade	;
				CmdReqBCodeInfoByItemVar->GradeList		=Thr->GradeList		;
			}
		}
		return;
	}
	CmdSetBCodeInfoByItem	*CmdSetBCodeInfoByItemVar=dynamic_cast<CmdSetBCodeInfoByItem *>(packet);
	if(CmdSetBCodeInfoByItemVar!=NULL){
		AlgorithmItemRoot	*a=SearchIDItem(CmdSetBCodeInfoByItemVar->ItemID);
		if(a!=NULL){
			BCRInspectionItem	*Item=dynamic_cast<BCRInspectionItem *>(a);
			if(Item!=NULL){
				BCRInspectionThreshold	*Thr=Item->GetThresholdW();

				Thr->CheckType		=CmdSetBCodeInfoByItemVar->CheckType	;
				Thr->QuilityGrade	=CmdSetBCodeInfoByItemVar->QuilityGrade	;
				Thr->GradeList		=CmdSetBCodeInfoByItemVar->GradeList	;
			}
		}
		return;
	}
}

//=================================================================
typedef HRESULT (STDAPICALLTYPE* CreateBarcodeReader)(IBarcodeReader**);
typedef HRESULT (STDAPICALLTYPE* DestroyBarcodeReader)(IBarcodeReader*);

CreateBarcodeReader fCreateBarcodeReader;
DestroyBarcodeReader fDestroyBarcodeReader=NULL;


BCRInspectionBase::BCRInspectionBase(LayersBase *Base)
:AlgorithmBase(Base)
{
	ColorBCR			=Qt::green;
	ColorSelected		=Qt::yellow;
	ColorActive			=Qt::red;
	TransparentLevel	=120;
	NegColorBCR			=Qt::darkGreen;
	NegColorSelected	=Qt::darkYellow;
	FixedMode			=false;
	FixedValue			=128;
	FixedValueMax		=180;
	FixedValueMin		=100;
	AdotpedLayer		=0;
	barReader			=NULL;
	BarcodeIsOnlyDigit	=true;
	IdealSize			=150;
	TryAllFilter		=true;

	LicenseKey		=/**/"Q19ZE7ES9AIIO6CCF5E8";

	BarcodeImageInvert		=false;
	BarcodeImageDespeckle	=false;
	BarcodeImageDilate		=false;
	BarcodeImageErode		=false;
	BarcodeImageSharp		=false;


	SetParam(&FixedMode			, /**/"Setting"		,/**/"FixedMode"		,LangSolver.GetString(XBCRInspection_LS,LID_0)/*"Fixed Mode"*/);
	SetParam(&FixedValue		, /**/"Setting"		,/**/"FixedValue"		,LangSolver.GetString(XBCRInspection_LS,LID_1)/*"Fixed value"*/);
	SetParam(&FixedValueMax		, /**/"Setting"		,/**/"FixedValueMax"	,LangSolver.GetString(XBCRInspection_LS,LID_2)/*"Fixed value as maximum"*/);
	SetParam(&FixedValueMin		, /**/"Setting"		,/**/"FixedValueMin"	,LangSolver.GetString(XBCRInspection_LS,LID_3)/*"Fixed value as minimum"*/);
	SetParam(&LicenseKey		, /**/"Setting"		,/**/"LicenseKey"		,LangSolver.GetString(XBCRInspection_LS,LID_4)/*"LicenseKey"*/);
	SetParam(&AdotpedLayer		, /**/"Setting"		,/**/"AdotpedLayer"		,LangSolver.GetString(XBCRInspection_LS,LID_5)/*"Adotped Layer , -1:Color"*/);	
	SetParam(&BarcodeIsOnlyDigit, /**/"Setting"		,/**/"BarcodeIsOnlyDigit"		,LangSolver.GetString(XBCRInspection_LS,LID_6)/*"Barcode is only Digit"*/);
	SetParam(&IdealSize			, /**/"Setting"		,/**/"IdealSize"		,"Ideal size insside");

	SetParam(&TryAllFilter			, /**/"Option"		,/**/"TryAllFilter"				,"Try al filter");
	SetParam(&BarcodeImageInvert	, /**/"Option"		,/**/"BarcodeImageInvert"		,LangSolver.GetString(XBCRInspection_LS,LID_7)/*"Option Invert"*/);
	SetParam(&BarcodeImageDespeckle	, /**/"Option"		,/**/"BarcodeImageDespeckle"	,LangSolver.GetString(XBCRInspection_LS,LID_8)/*"Option Despeckle"*/);
	SetParam(&BarcodeImageDilate	, /**/"Option"		,/**/"BarcodeImageDilate"		,LangSolver.GetString(XBCRInspection_LS,LID_9)/*"Option Dilate"*/);
	SetParam(&BarcodeImageErode		, /**/"Option"		,/**/"BarcodeImageErode"		,LangSolver.GetString(XBCRInspection_LS,LID_10)/*"Option Erode"*/);
	SetParam(&BarcodeImageSharp		, /**/"Option"		,/**/"BarcodeImageSharp"		,LangSolver.GetString(XBCRInspection_LS,LID_11)/*"Option Sharp"*/);
}

BCRInspectionBase::~BCRInspectionBase(void)
{
	if(fDestroyBarcodeReader!=NULL){
		fDestroyBarcodeReader(barReader);
		fDestroyBarcodeReader=NULL;
	}
}

AlgorithmDrawAttr	*BCRInspectionBase::CreateDrawAttr(void)
{
	return new BCRInspectionDrawAttr();
}

static	VARIANT_BOOL	Boo=true;

void	BCRInspectionBase::InitialAfterParamLoaded(void)
{
	DTKLib.setFileName(/**/"DTKBarReader.dll");
	if(DTKLib.load()==true){
		fCreateBarcodeReader	=(CreateBarcodeReader)DTKLib.resolve(/**/"CreateBarcodeReader");
		fDestroyBarcodeReader	=(DestroyBarcodeReader)DTKLib.resolve(/**/"DestroyBarcodeReader");
		if(fCreateBarcodeReader(&barReader)!=0){
			return;
		}
		ILicManager *licenseManager;
		barReader->get_LicenseManager(&licenseManager);

		wchar_t	LicenseStr[2000];
		memset(LicenseStr,0,sizeof(LicenseStr));
		LicenseKey.toWCharArray(LicenseStr);
		licenseManager->AddLicenseKey(LicenseStr);

		QString	Lic1=/**/"Q19ZE7ES9AIIO6CCF5E8";
		memset(LicenseStr,0,sizeof(LicenseStr));
		Lic1.toWCharArray(LicenseStr);
		licenseManager->AddLicenseKey(LicenseStr);

		QString	Lic2=/**/"FF531F20-EF4A-47e6-8C05-13FB16C77B2F";
		memset(LicenseStr,0,sizeof(LicenseStr));
		Lic2.toWCharArray(LicenseStr);
		licenseManager->AddLicenseKey(LicenseStr);

		//licenseManager->AddLicenseKey(L"Q19ZE7ES9AIIO6CCF5E8");	//This will remove server license popup window.
		//licenseManager->AddLicenseKey(L"FF531F20-EF4A-47e6-8C05-13FB16C77B2F");	//This will remove server license popup window.
		licenseManager->get_IsLicensed(&Boo);

		barReader->put_BarcodeTypes(BT_DataMatrix);
		barReader->put_ThresholdMode(TM_Adaptive);
	}
}

void	BCRInspectionBase::TransmitDirectly(GUIDirectMessage *packet)
{
	CmdReqBCodeResults	*CmdReqBCodeResultsVar=dynamic_cast<CmdReqBCodeResults *>(packet);
	if(CmdReqBCodeResultsVar!=NULL){
		for(int page=0;page<GetPageNumb();page++){
			AlgorithmInPageRoot	*Pg=GetPageData(page);
			Pg->TransmitDirectly(packet);
		}
		return;
	}
	CmdCreateBCRInspectionThreshold	*CmdCreateBCRInspectionThresholdVar=dynamic_cast<CmdCreateBCRInspectionThreshold *>(packet);
	if(CmdCreateBCRInspectionThresholdVar!=NULL){
		CmdCreateBCRInspectionThresholdVar->Item=new BCRInspectionItem();
		CmdCreateBCRInspectionThresholdVar->Threshold=(BCRInspectionThreshold *)CmdCreateBCRInspectionThresholdVar->Item->CreateThresholdInstance();
		return;
	}
	CmdBCRInspectionSendTryThreshold	*CmdBCRInspectionSendTryThresholdVar=dynamic_cast<CmdBCRInspectionSendTryThreshold *>(packet);
	if(CmdBCRInspectionSendTryThresholdVar!=NULL){
		CmdBCRInspectionSendTryThresholdVar->PTry=new BCRInspectionSendTryThreshold();
		CmdBCRInspectionSendTryThresholdVar->Target=new BCRInspectionItem();
		AlgorithmInPagePI		*Ap=(AlgorithmInPagePI *)(CmdBCRInspectionSendTryThresholdVar->Src->GetParentInPage());
		CmdBCRInspectionSendTryThresholdVar->Target->SetParent(Ap);
		QBuffer	Buff(&CmdBCRInspectionSendTryThresholdVar->ThresholdDataForTarget);
		Buff.open(QIODevice::ReadWrite);
		CmdBCRInspectionSendTryThresholdVar->Target->GetThresholdW()->Load(&Buff);
		CmdBCRInspectionSendTryThresholdVar->PTry->Calc( CmdBCRInspectionSendTryThresholdVar->Target
														,CmdBCRInspectionSendTryThresholdVar->Src
														,this);
		return;
	}	
}

bool	BCRInspectionBase::GetBCR(const QString &FileName ,QString &Result)
{
	bool	Ret=false;

	if(barReader!=NULL){
		BarcodeOrientationEnum orientation = BO_Unknown;
		barReader->put_BarcodeOrientation(orientation);

		barReader->put_BarcodesToRead(1);
		barReader->put_ScanInterval(1);
		barReader->put_ScanPage(0);
		barReader->put_Threshold(45);
		barReader->put_QuietZoneSize(QZ_Normal);
		barReader->put_PDFReadingType(PDF_Images);
		if(FixedMode==false)
			barReader->put_ThresholdMode(TM_Adaptive);
		else{
			barReader->put_ThresholdMode(TM_Fixed);
			barReader->put_Threshold(FixedValue);
		}

		barReader->put_ImageInvert	(BarcodeImageInvert);
		barReader->put_ImageDespeckle(BarcodeImageDespeckle);
		barReader->put_ImageDilate	(BarcodeImageDilate);
		barReader->put_ImageErode	(BarcodeImageErode);
		barReader->put_ImageSharp	(BarcodeImageSharp);

		wchar_t	FileNameStr[2000];
		memset(FileNameStr,0,sizeof(FileNameStr));
		FileName.toWCharArray(FileNameStr);

		if(barReader->ReadFromFile(FileNameStr)!=0){
			return false;
		}	
		if(GetBCR(Result)==false){
			if(GetBCRFilterVarious(Result)==false){
				if(FixedMode==true){
					for(int i=1;i<50;i++){
						int	v=FixedValue+i*5;
						if(v<=FixedValueMax){
							barReader->put_Threshold(v);
							if(barReader->ReadFromFile(FileNameStr)!=0){
								return false;
							}
							if(GetBCR(Result)==true){
								Ret=true;
								return Ret;
							}
						}
						v=FixedValue-i*5;
						if(FixedValueMin<=v){
							barReader->put_Threshold(v);
							if(barReader->ReadFromFile(FileNameStr)!=0){
								return false;
							}
							if(GetBCR(Result)==true){
								Ret=true;
								return Ret;
							}
						}
					}
					for(int i=1;i<50;i++){
						int	v=FixedValue+i;
						if(v<=FixedValueMax){
							barReader->put_Threshold(v);
							if(barReader->ReadFromFile(FileNameStr)!=0){
								return false;
							}
							if(GetBCR(Result)==true){
								Ret=true;
								return Ret;
							}
						}
						v=FixedValue-i;
						if(FixedValueMin<=v){
							barReader->put_Threshold(v);
							if(barReader->ReadFromFile(FileNameStr)!=0){
								return false;
							}
							if(GetBCR(Result)==true){
								Ret=true;
								return Ret;
							}
						}
					}
				}
			}
		}
		else{
			Ret=true;
		}
	}
	return Ret;
}


bool	BCRInspectionBase::GetBCR(QString &Result)
{
	if(barReader!=NULL){
		IBarcodeCollection * barcodes = NULL;
		if(barReader->get_Barcodes(&barcodes)!=0){
			return false;
		}

		LONG barcodesCount;
		barcodes->get_Count(&barcodesCount);
		if (barcodesCount > 0)
		{
			for (int i=0; i<barcodesCount; i++)
			{
				IBarcode * bar;
				barcodes->get_Item(i, &bar);

				// Barcode string
				BSTR barcodeString;
				bar->get_BarcodeString(&barcodeString);
				Result=QString::fromWCharArray(barcodeString);
				SysFreeString(barcodeString);
				bar->Release();
				if(BarcodeIsOnlyDigit==true){
					bool	ok;
					qlonglong r=Result.toLongLong (&ok);
					if(ok==false){
						Result.clear();
					}
				}
				return true;
			}
		}
		if (barcodes){
			barcodes->Release();
		}
	}
	return false;
}

bool	BCRInspectionBase::GetBCRFilterVarious(QString &Result)
{
	if(TryAllFilter==true && barReader!=NULL){
		for(int i=0;i<32;i++){
			barReader->put_ImageInvert		((i&0x01)!=0?true:false);
			barReader->put_ImageDespeckle	((i&0x02)!=0?true:false);
			barReader->put_ImageDilate		((i&0x04)!=0?true:false);
			barReader->put_ImageErode		((i&0x08)!=0?true:false);
			barReader->put_ImageSharp		((i&0x10)!=0?true:false);
			if(GetBCR(Result)==true){
				return true;
			}
		}
	}
	return false;
}
QString	BCRInspectionBase::GetNameByCurrentLanguage(void)
{
	return "バーコード検査";
}

BCRInspectionReqTryThreshold::BCRInspectionReqTryThreshold(void)
{
	GlobalPage=-1;
	BCRInspectionItemID=-1;
}
bool	BCRInspectionReqTryThreshold::Save(QIODevice *f)
{
	if(::Save(f,GlobalPage)==false)
		return false;
	if(::Save(f,BCRInspectionItemID)==false)
		return false;
	if(Threshold.Save(f)==false)
		return false;
	return true;
}
bool	BCRInspectionReqTryThreshold::Load(QIODevice *f,LayersBase *LBase)
{
	if(::Load(f,GlobalPage)==false)
		return false;
	if(::Load(f,BCRInspectionItemID)==false)
		return false;
	if(Threshold.Load(f,LBase)==false)
		return false;
	return true;
}

BCRInspectionSendTryThreshold::BCRInspectionSendTryThreshold(void)
{
	Result	=new ResultInItemPI();
	ResultQuality	=0;;
}
BCRInspectionSendTryThreshold::~BCRInspectionSendTryThreshold(void)
{
	if(Result!=NULL){
		delete	Result;
		Result=NULL;
	}
}
bool	BCRInspectionSendTryThreshold::Save(QIODevice *f)
{
	if(Result->Save(f)==false)
		return false;
	if(::Save(f,ResultQuality	)==false)
		return false;
	if(::Save(f,ResultStr	)==false)
		return false;

	return true;
}
bool	BCRInspectionSendTryThreshold::Load(QIODevice *f)
{
	if(Result->Load(f)==false)
		return false;
	if(::Load(f,ResultQuality	)==false)
		return false;
	if(::Load(f,ResultStr	)==false)
		return false;

	return true;
}

void	BCRInspectionSendTryThreshold::ConstructList(BCRInspectionReqTryThreshold *reqPacket,BCRInspectionBase *Base)
{
	Result->SetAddedData(this,1,sizeof(this));
	BCRInspectionInPage		*BP=(BCRInspectionInPage *)Base->GetPageData(Base->GetLayersBase()->GetLocalPageFromGlobal(reqPacket->GlobalPage));
	if(BP!=NULL){
		BCRInspectionItem		*BI=(BCRInspectionItem *)BP->SearchIDItem(reqPacket->BCRInspectionItemID);
		if(BI!=NULL){
			Calc(&reqPacket->Threshold,BI,Base);
		}
	}
}

void	BCRInspectionSendTryThreshold::Calc(BCRInspectionItem *Target,BCRInspectionItem *Src,BCRInspectionBase *Base)
{
	Base->GetLayersBase()->SetStartInspectionTimeMilisec(::GetComputerMiliSec());
	
	Target->SetParent(Src->GetParent());
	Target->SetArea(Src->GetArea());
	ExecuteInitialAfterEditInfo DummyEInfo;
	DummyEInfo.ExecuteInitialAfterEdit_Changed=ExecuteInitialAfterEdit_ChangedAlgorithm;
	Target->ExecuteInitialAfterEdit	(0,0,Result,DummyEInfo);
	Target->AVector				=Src->AVector;
	//BI->ExecuteInitialAfterEdit	(0,Result ,Base->GetLayersBase()->GetEntryPoint());

	Target->ExecuteStartByInspection	(0,0,Result);
	Target->ExecuteProcessing			(0,0,Result);

	ResultStr		=Target->Result;
	ResultQuality	=Result->GetResultDouble();
}
