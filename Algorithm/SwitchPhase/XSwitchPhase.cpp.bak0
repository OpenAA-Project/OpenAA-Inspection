/*******************************************************************************
** Copyright (C) 2005-2008 MEGATRADE corp. All rights reserved.
**
** Please consult your licensing agreement or contact customer@mega-trade.co.jp 
** if any conditions of this licensing agreement are not clear to you.
**
** This file is C:\Regulus64v5\SwitchPhase\XSwitchPhase.cpp
** Author : YYYYYYYYYY
****************************************************************************-**/
//#include "SwitchPhaseResource.h"
#include "XSwitchPhase.h"
#include "XResult.h"
#include "swap.h"
#include "XAlgorithmDLL.h"
#include <ctype.h>
#include "XDataInLayer.h"
#include "XCriticalFunc.h"
#include "SelectAlgorithmListDialog.h"
#include<omp.h>
//#include "XSwitchPhasePacket.h"

//=====================================================================================

void	SwitchPhaseInPage::TransmitDirectly(GUIDirectMessage *packet)
{
	AddSwitchPhaseAreaPacket	*AddSwitchPhaseAreaPacketVar=dynamic_cast<AddSwitchPhaseAreaPacket *>(packet);
	if(AddSwitchPhaseAreaPacketVar!=NULL){
		SwitchPhaseItem	*item=(SwitchPhaseItem *)CreateItem();
		item->SetItemName(AddSwitchPhaseAreaPacketVar->AreaName);
		item->SetArea(AddSwitchPhaseAreaPacketVar->Area);
		item->SetManualCreated(true);
		item->GetThresholdW()->SearchDot=AddSwitchPhaseAreaPacketVar->SearchDot;
		AppendItem(item);
		return;
	}
	CmdPhaseItemList	*CmdPhaseItemListVar=dynamic_cast<CmdPhaseItemList *>(packet);
	if(CmdPhaseItemListVar!=NULL){
		for(int phase=0;phase<GetPhaseNumb();phase++){
			AlgorithmInPageInOnePhase	*Ph=GetParentBase()->GetPageDataPhase(phase);
			SwitchPhaseInPage	*SPage=(SwitchPhaseInPage *)Ph->GetPageData(GetPage());
			PhaseItemList	*p=new PhaseItemList();
			p->Phase=phase;
			p->Page=GetLayersBase()->GetGlobalPageFromLocal(GetPage());
			p->ItemCount=SPage->GetItemCount();
			CmdPhaseItemListVar->ItemsInfos.AppendList(p);
		}
		return;
	}
	CmdItemInfoList	*CmdItemInfoListVar=dynamic_cast<CmdItemInfoList *>(packet);
	if(CmdItemInfoListVar!=NULL){
		AlgorithmInPageInOnePhase	*Ph=GetParentBase()->GetPageDataPhase(CmdItemInfoListVar->Phase);
		SwitchPhaseInPage	*SPage=(SwitchPhaseInPage *)Ph->GetPageData(GetPage());
		for(AlgorithmItemPI*Item=SPage->GetFirstData();Item!=NULL;Item=Item->GetNext()){
			SwitchPhaseItem	*AItem=(SwitchPhaseItem	*)Item;
			ItemInfoList	*a=new ItemInfoList();
			a->Phase=CmdItemInfoListVar->Phase;
			a->Page	=GetLayersBase()->GetGlobalPageFromLocal(GetPage());
			a->ItemID=AItem->GetID();
			AItem->GetCenter(a->Cx,a->Cy);
			a->SearchDot=AItem->GetThresholdR(GetLayersBase())->SearchDot;
			CmdItemInfoListVar->ItemsInfos.AppendList(a);
		}
		return;
	}
	ModifySwitchPhasePacket	*ModifySwitchPhasePacketVar=dynamic_cast<ModifySwitchPhasePacket *>(packet);
	if(ModifySwitchPhasePacketVar!=NULL){
		SwitchPhaseItem	*Item=(SwitchPhaseItem*)SearchIDItem(ModifySwitchPhasePacketVar->ItemID);
		if(Item!=NULL){
			Item->GetThresholdW()->SearchDot=ModifySwitchPhasePacketVar->SearchDot;
		}
		return;
	}
	CmdGatherItemResult	*CmdGatherItemResultVar=dynamic_cast<CmdGatherItemResult *>(packet);
	if(CmdGatherItemResultVar!=NULL){
		for(AlgorithmItemPI*Item=GetFirstData();Item!=NULL;Item=Item->GetNext()){
			SwitchPhaseItem	*AItem=(SwitchPhaseItem	*)Item;
			PhaseItemResultList	*p=new PhaseItemResultList();
			p->Phase=GetPhaseCode();
			p->ItemID=AItem->GetID();
			p->MatchingResult=AItem->MatchingResult;
			CmdGatherItemResultVar->Result.AppendList(p);
		}
		return;
	}
	CmdAdjustItemPosition	*CmdAdjustItemPositionVar=dynamic_cast<CmdAdjustItemPosition *>(packet);
	if(CmdAdjustItemPositionVar!=NULL){
		AlgorithmInPageInOnePhase	*SPh=GetParentBase()->GetPageDataPhase(CmdAdjustItemPositionVar->SourcePhase);
		if(SPh!=NULL){
		
			ListPhasePageLayerPack	CapturedList;
			GetLayersBase()->MakeCapturedAllList(CapturedList);
		
			PageDataInOnePhase	*Src=GetLayersBase()->GetPageDataPhase(GetPhaseCode());
			PageDataInOnePhase	*Dst=GetLayersBase()->GetPageDataPhase(CmdAdjustItemPositionVar->SourcePhase);
			DataInPage	*Sp=Src->GetPageData(GetPage());
			DataInPage	*Dp=Dst->GetPageData(GetPage());
			for(int Layer=0;Layer<GetLayerNumb();Layer++){
				DataInLayer	*SL=Sp->GetLayerData(Layer);
				DataInLayer	*DL=Dp->GetLayerData(Layer);
				DL->GetTargetBuff()=SL->GetMasterBuff();
			}
			GetLayersBase()->SetCurrentPhase(CmdAdjustItemPositionVar->SourcePhase);
			int	LastCurrentCalcPoint=GetLayersBase()->GetCurrentCalcPoint();
			GetLayersBase()->SetProcessDone(false);
			GetLayersBase()->SetCurrentCalcPoint(LastCurrentCalcPoint);
			GetLayersBase()->ExecuteStartByInspection	(false);

			GetLayersBase()->SetProcessDone(false);
			GetLayersBase()->ExecuteCaptured(CapturedList,false);

			int	Index=GetLayersBase()->GetIndexInCurrentStateExecuter(DataInExecuter::FinExecuteStartByInspection);
			GetLayersBase()->SetProcessDone(false);
			GetLayersBase()->SetCurrentStateInExecuter(Index ,DataInExecuter::FinExecuteStartByInspection);
			GetLayersBase()->ExecutePreAlignment		(false);

			GetLayersBase()->SetProcessDone(false);
			GetLayersBase()->SetCurrentStateInExecuter(Index ,DataInExecuter::FinExecutePreAlignment);
			GetLayersBase()->ExecuteAlignment			(false);

			AlgorithmInPageRoot	*SAp=SPh->GetPageData(GetPage());
			for(AlgorithmItemPI*Item=GetFirstData();Item!=NULL;Item=Item->GetNext()){
				int	Cx,Cy;
				Item->GetCenter(Cx,Cy);
				AlignmentPacket2D	V;
				V.PosXOnTarget=Cx;
				V.PosYOnTarget=Cy;
				V.ShiftX=0;
				V.ShiftY=0;
				SAp->GetAlignmentForProcessing(V);
				Item->MoveTo(V.ShiftX,V.ShiftY);
			}
		}
		return;
	}
}

bool	SwitchPhaseInPage::AppendItem(AlgorithmItemRoot *item)
{
	SwitchPhaseBase	*ABase=(SwitchPhaseBase *)GetParentBase();
	if(ABase->Only1MarkInPage==true){
		AlgorithmItemPointerListContainer ItemPointers;
		GetAllItems(ItemPointers);
		RemoveItems(ItemPointers);
	}
	return AlgorithmInPagePI::AppendItem(item);
}

struct	AdjustPointFuncStruct
{
	AlgorithmInPageRoot	*SrcAp;
	int		GlobalShiftX;
	int		GlobalShiftY;
};


static	bool AdjustPointFunc(void *caller,AlgorithmItemRoot *item)
{
	int	cx,cy;
	AlgorithmInPageRoot	*SrcAp=((struct	AdjustPointFuncStruct*)caller)->SrcAp;
	AlignmentPacket2D	V;
	item->GetCenter(cx,cy);
	V.PosXOnTarget=cx;
	V.PosYOnTarget=cy;
	V.ShiftX=0;
	V.ShiftY=0;
	SrcAp->GetAlignmentForProcessing(V);
	item->MoveTo(V.ShiftX-((struct	AdjustPointFuncStruct*)caller)->GlobalShiftX
				,V.ShiftY-((struct	AdjustPointFuncStruct*)caller)->GlobalShiftY);
	return true;
}

ExeResult	SwitchPhaseInPage::ExecuteInitialAfterEdit	(int ExeID 
														,ResultInPageRoot *Res
														,ExecuteInitialAfterEditInfo &EInfo)
{
	ExeResult	Ret=AlgorithmInPagePI::ExecuteInitialAfterEdit	(ExeID ,Res,EInfo);

	MasterShiftX=0;
	MasterShiftY=0;
	SwitchPhaseBase	*ABase=(SwitchPhaseBase *)GetParentBase();
	if(ABase!=NULL && ABase->SourcePhaseInInitial>=0){
		if(ABase->CopiedAlgorithmDim.GetCount()>0){
			PageDataInOnePhase	*Src=GetLayersBase()->GetPageDataPhase(0);
			int phase=GetPhaseCode();
			if(phase>0){
				PageDataInOnePhase	*Dst=GetLayersBase()->GetPageDataPhase(phase);
				DataInPage	*Sp=Src->GetPageData(GetPage());
				DataInPage	*Dp=Dst->GetPageData(GetPage());
				for(int Layer=0;Layer<GetLayerNumb();Layer++){
					DataInLayer	*SL=Sp->GetLayerData(Layer);
					DataInLayer	*DL=Dp->GetLayerData(Layer);
					SL->GetTargetBuff()=DL->GetMasterBuff();
				}
				AlignmentPacket2D	V;
				V.PosXOnTarget=GetDotPerLine()/2;
				V.PosYOnTarget=GetMaxLines()/2;

				GetLayersBase()->SetCurrentPhase(0);
				AlgorithmBase	*AlignedBase=NULL;
				

				if(ABase->ModeCopyAlignment==true){
					for(LogicDLL *L=GetLayersBase()->GetLogicDLLBase()->GetFirst();L!=NULL;L=L->GetNext()){
						if(L->CheckAlgorithmType(AlgorithmBit_TypePieceProcessing)==true
						|| (L->CheckAlgorithmType(AlgorithmBit_TypeAlignment)==true
						 && L->CheckAlgorithmType(AlgorithmBit_TypePieceProcessing)==false)){
							AlgorithmBase	*mABase=L->GetInstance();
							if(mABase!=NULL){

								AlignedBase	=mABase;
								AlgorithmInPageInOnePhase	*sPh=mABase->GetPageDataPhase(0);
								AlgorithmInPageRoot			*sAp=sPh->GetPageData(GetPage());
								ResultBaseForAlgorithmRoot	*sResAlgo=Res->GetResultInspection()->GetResultBaseForAlgorithm(mABase);
								ResultBasePhase				*sResPhase=sResAlgo->GetPageDataPhase(0);
								ResultInPageRoot			*sResPage=sResPhase->GetPageData(GetPage());

								GetLayersBase()->SetProcessDone(false);
								sAp->ExecuteStartByInspection	(ExeID ,sResPage);

								GetLayersBase()->SetProcessDone(false);
								sAp->ExecutePreAlignment		(ExeID ,sResPage);

								GetLayersBase()->SetProcessDone(false);
								sAp->ExecuteAlignment			(ExeID ,sResPage);

								sAp->GetAlignmentForProcessing(V);	//Get shift of alignment for phase0-alignment


								AlgorithmInPageInOnePhase	*mPh=mABase->GetPageDataPhase(phase);
								AlgorithmInPageRoot			*mAp=mPh->GetPageData(GetPage());
								ResultBaseForAlgorithmRoot	*mResAlgo=Res->GetResultInspection()->GetResultBaseForAlgorithm(mABase);
								ResultBasePhase				*mResPhase=mResAlgo->GetPageDataPhase(phase);
								ResultInPageRoot			*mResPage=mResPhase->GetPageData(GetPage());
							
								AlgorithmInPageInOnePhase	*SrcPh=mABase->GetPageDataPhase(0);
								AlgorithmInPageRoot	*SrcAp=SrcPh->GetPageData(GetPage());

								IntList	LayerList;
								for(int layer=0;layer<GetLayerNumb();layer++){
									LayerList.Add(layer);
								}
								//mAp->SelectAll(LayerList);
								//mAp->DeleteSelectedItems(LayerList);
								mAp->RemoveAllDatas();
									
								mAp->CopyFrom(mABase
										,SrcAp
										,V.ShiftX,V.ShiftY
										,-1 ,-1
										,true);

								struct	AdjustPointFuncStruct	Caller;
								Caller.SrcAp=SrcAp;
								Caller.GlobalShiftX=V.ShiftX;
								Caller.GlobalShiftY=V.ShiftY;
								AlgorithmItemPointerListContainer Items;
								mAp->EnumItems(&Caller,Items , AdjustPointFunc);

								mAp->ExecuteInitialAfterEdit(ExeID ,mResPage,EInfo);

								GetLayersBase()->SetProcessDone(false);
								mAp->ExecuteStartByInspection	(ExeID ,mResPage);

								GetLayersBase()->SetProcessDone(false);
								mAp->ExecutePreAlignment		(ExeID ,mResPage);

								GetLayersBase()->SetProcessDone(false);
								mAp->ExecuteAlignment			(ExeID ,mResPage);
							}
						}
					}

					for(LogicDLL *L=GetLayersBase()->GetLogicDLLBase()->GetFirst();L!=NULL;L=L->GetNext()){
						if(L->CheckAlgorithmType(AlgorithmBit_TypePieceProcessing)==true
						|| (L->CheckAlgorithmType(AlgorithmBit_TypeAlignment)==true
						 && L->CheckAlgorithmType(AlgorithmBit_TypePieceProcessing)==false)){
							AlgorithmBase	*mABase=L->GetInstance();
							if(mABase!=NULL){

								AlignedBase	=mABase;
								AlgorithmInPageInOnePhase	*sPh=mABase->GetPageDataPhase(0);
								AlgorithmInPageRoot			*sAp=sPh->GetPageData(GetPage());
								ResultBaseForAlgorithmRoot	*sResAlgo=Res->GetResultInspection()->GetResultBaseForAlgorithm(mABase);
								ResultBasePhase				*sResPhase=sResAlgo->GetPageDataPhase(0);
								ResultInPageRoot			*sResPage=sResPhase->GetPageData(GetPage());

								GetLayersBase()->SetProcessDone(false);
								sAp->ExecuteStartByInspection	(ExeID ,sResPage);

								GetLayersBase()->SetProcessDone(false);
								sAp->ExecutePreAlignment		(ExeID ,sResPage);

								GetLayersBase()->SetProcessDone(false);
								sAp->ExecuteAlignment			(ExeID ,sResPage);

								sAp->GetAlignmentForProcessing(V);	//Get shift of alignment for phase0-alignment
							}
						}
					}
					MasterShiftX=V.ShiftX;
					MasterShiftY=V.ShiftY;
					if(ABase->ModeCopyAlgorithmInLoadMaster==true
					|| EInfo.CalledInLoadMaster==false){
						for(RootNameList *RList=ABase->CopiedAlgorithmDim.GetFirst();RList!=NULL;RList=RList->GetNext()){
							AlgorithmBase	*tABase=GetLayersBase()->GetAlgorithmBase(RList->DLLRoot,RList->DLLName);
							if(tABase!=NULL && ABase!=AlignedBase){
								AlgorithmInPageInOnePhase	*SrcPh=tABase->GetPageDataPhase(0);
								AlgorithmInPageRoot	*SrcAp=SrcPh->GetPageData(GetPage());
								AlgorithmInPageInOnePhase	*DstPh=tABase->GetPageDataPhase(phase);
								AlgorithmInPageRoot	*DstAp=DstPh->GetPageData(GetPage());

								IntList	LayerList;
								for(int layer=0;layer<GetLayerNumb();layer++){
									LayerList.Add(layer);
								}
								DstAp->RemoveAllDatas();

								DstAp->CopyFrom(tABase
											,SrcAp
											,V.ShiftX,V.ShiftY
											,-1 ,-1
											,true);

								struct	AdjustPointFuncStruct	Caller;
								Caller.SrcAp=SrcAp;
								Caller.GlobalShiftX=V.ShiftX;
								Caller.GlobalShiftY=V.ShiftY;
								AlgorithmItemPointerListContainer Items;
								DstAp->EnumItems(&Caller,Items , AdjustPointFunc);
							}
						}
					}
					for(LogicDLL *L=GetLayersBase()->GetLogicDLLBase()->GetFirst();L!=NULL;L=L->GetNext()){
						if(L->CheckAlgorithmType(AlgorithmBit_TypePieceProcessing)==true){
							AlgorithmBase	*mABase=L->GetInstance();
							if(mABase!=NULL){
								AlgorithmInPageInOnePhase	*mPh=mABase->GetPageDataPhase(phase);
								AlgorithmInPageRoot			*mAp=mPh->GetPageData(GetPage());
								ResultBaseForAlgorithmRoot	*mResAlgo=Res->GetResultInspection()->GetResultBaseForAlgorithm(mABase);
								ResultBasePhase				*mResPhase=mResAlgo->GetPageDataPhase(phase);
								ResultInPageRoot			*mResPage=mResPhase->GetPageData(GetPage());
								mAp->ExecuteInitialAfterEdit(ExeID ,mResPage,EInfo);
							}
						}
					}
					for(LogicDLL *L=GetLayersBase()->GetLogicDLLBase()->GetFirst();L!=NULL;L=L->GetNext()){
						if(L->CheckAlgorithmType(AlgorithmBit_TypeAlignment)==true
						&& L->CheckAlgorithmType(AlgorithmBit_TypePieceProcessing)==false){
							AlgorithmBase	*mABase=L->GetInstance();
							if(mABase!=NULL){
								AlgorithmInPageInOnePhase	*mPh=mABase->GetPageDataPhase(phase);
								AlgorithmInPageRoot			*mAp=mPh->GetPageData(GetPage());
								ResultBaseForAlgorithmRoot	*mResAlgo=Res->GetResultInspection()->GetResultBaseForAlgorithm(mABase);
								ResultBasePhase				*mResPhase=mResAlgo->GetPageDataPhase(phase);
								ResultInPageRoot			*mResPage=mResPhase->GetPageData(GetPage());
								mAp->ExecuteInitialAfterEdit(ExeID ,mResPage,EInfo);
							}
						}
					}
				}
				else{
					for(LogicDLL *L=GetLayersBase()->GetLogicDLLBase()->GetFirst();L!=NULL;L=L->GetNext()){
						if(L->CheckAlgorithmType(AlgorithmBit_TypePieceProcessing)==true
						|| (L->CheckAlgorithmType(AlgorithmBit_TypeAlignment)==true
						 && L->CheckAlgorithmType(AlgorithmBit_TypePieceProcessing)==false)){
							AlgorithmBase	*mABase=L->GetInstance();
							if(mABase!=NULL){
								AlignedBase	=mABase;
								AlgorithmInPageInOnePhase	*sPh=mABase->GetPageDataPhase(0);
								AlgorithmInPageRoot			*sAp=sPh->GetPageData(GetPage());
								ResultBaseForAlgorithmRoot	*sResAlgo=Res->GetResultInspection()->GetResultBaseForAlgorithm(mABase);
								ResultBasePhase				*sResPhase=sResAlgo->GetPageDataPhase(0);
								ResultInPageRoot			*sResPage=sResPhase->GetPageData(GetPage());

								AlgorithmInPageInOnePhase	*mPh=mABase->GetPageDataPhase(phase);
								AlgorithmInPageRoot			*mAp=mPh->GetPageData(GetPage());
								ResultBaseForAlgorithmRoot	*mResAlgo=Res->GetResultInspection()->GetResultBaseForAlgorithm(mABase);
								ResultBasePhase				*mResPhase=mResAlgo->GetPageDataPhase(phase);
								ResultInPageRoot			*mResPage=mResPhase->GetPageData(GetPage());
							
								mAp->ExecuteInitialAfterEdit(ExeID ,mResPage,EInfo);

								GetLayersBase()->SetProcessDone(false);
								mAp->ExecuteStartByInspection	(ExeID ,mResPage);	
							}
						}
					}
					if(ABase->ModeCopyAlgorithmInLoadMaster==true
					|| EInfo.CalledInLoadMaster==false){
						for(RootNameList *RList=ABase->CopiedAlgorithmDim.GetFirst();RList!=NULL;RList=RList->GetNext()){
							AlgorithmBase	*tABase=GetLayersBase()->GetAlgorithmBase(RList->DLLRoot,RList->DLLName);
							if(tABase!=NULL && ABase!=AlignedBase){
								AlgorithmInPageInOnePhase	*SrcPh=tABase->GetPageDataPhase(0);
								AlgorithmInPageRoot	*SrcAp=SrcPh->GetPageData(GetPage());
								AlgorithmInPageInOnePhase	*DstPh=tABase->GetPageDataPhase(phase);
								AlgorithmInPageRoot	*DstAp=DstPh->GetPageData(GetPage());

								IntList	LayerList;
								for(int layer=0;layer<GetLayerNumb();layer++){
									LayerList.Add(layer);
								}
								DstAp->RemoveAllDatas();

								DstAp->CopyFrom(tABase
											,SrcAp
											,0,0
											,-1 ,-1
											,true);
							}
						}
					}
				}

				Ret=AlgorithmInPagePI::ExecuteInitialAfterEdit	(ExeID ,Res,EInfo);
			}
			else{
				for(LogicDLL *L=GetLayersBase()->GetLogicDLLBase()->GetFirst();L!=NULL;L=L->GetNext()){
					if(L->CheckAlgorithmType(AlgorithmBit_TypePieceProcessing)==true
					|| (L->CheckAlgorithmType(AlgorithmBit_TypeAlignment)==true
					 && L->CheckAlgorithmType(AlgorithmBit_TypePieceProcessing)==false)){
						AlgorithmBase	*mABase=L->GetInstance();
						if(mABase!=NULL){
							AlgorithmInPageInOnePhase	*sPh=mABase->GetPageDataPhase(0);
							AlgorithmInPageRoot			*sAp=sPh->GetPageData(GetPage());
							ResultBaseForAlgorithmRoot	*sResAlgo=Res->GetResultInspection()->GetResultBaseForAlgorithm(mABase);
							ResultBasePhase				*sResPhase=sResAlgo->GetPageDataPhase(0);
							ResultInPageRoot			*sResPage=sResPhase->GetPageData(GetPage());

							GetLayersBase()->SetProcessDone(false);
							sAp->ExecuteInitialAfterEdit	(ExeID ,sResPage,EInfo);
						}
					}
				}
			}
		}
	}
	return Ret;
}

double	SwitchPhaseInPage::GetMatchingRate(void)
{
	double	M=1.0;
	if(GetItemCount()==0)
		return 0;

	for(AlgorithmItemPI	*L=GetFirstData();L!=NULL;L=L->GetNext()){
		SwitchPhaseItem	*Item=(SwitchPhaseItem *)L;
		M*=Item->MatchingResult;
	}
	return M;
}

struct	AreaStruct
{
	FlexArea	*Area;
	FlexAreaImageListCoeff	*AreaCoef;
	double		V;
	int			AdoptedLayer;

	AreaStruct(void)	{	AdoptedLayer	=-1;	Area=NULL;	AreaCoef=NULL;	}
	~AreaStruct(void)	{	delete	Area;	delete	AreaCoef;	}
};

static	int	ADimSortFunc1(const void *a ,const void *b)
{
	struct	AreaStruct	*pa=(struct	AreaStruct *)a;
	struct	AreaStruct	*pb=(struct	AreaStruct *)b;
	if(pa->V<pb->V)
		return 1;
	if(pa->V>pb->V)
		return -1;
	return 0;
}
static	int	ADimSortFunc2(const void *a ,const void *b)
{
	struct	AreaStruct	*pa=(struct	AreaStruct *)a;
	struct	AreaStruct	*pb=(struct	AreaStruct *)b;
	if(pa->V<pb->V)
		return -1;
	if(pa->V>pb->V)
		return 1;
	return 0;
}


void	SwitchPhaseInPage::GenerateItemAutomaticly(void)
{
	IntList LayerList;
	for(int Layer=0;Layer<GetLayerNumb();Layer++){
		LayerList.Add(Layer);
	}

	SelectAll(LayerList);
	ListPageLayerIDPack Items;
	EnumSelectedItems(Items);
	for(int Layer=0;Layer<GetLayerNumb();Layer++){
		IntList IDList;
		Items.MakeIDList(Layer ,IDList);
		RemoveItemsInPage(Layer,IDList);
	}
	ConstMapBufferListContainer MaskMap;
	GetReflectionMap(_Reflection_Mask,MaskMap);
	ConstMapBuffer Map;
	MaskMap.BindOr(Map);

	FlexArea	MaskArea;
	BYTE    **MAreaMap	=MakeMatrixBuff(Map.GetXByte() ,Map.GetYLen());
	BYTE    **TmpMap	=MakeMatrixBuff(Map.GetXByte() ,Map.GetYLen());
	MatrixBuffCopy	(MAreaMap			,Map.GetXByte() ,Map.GetYLen()
					,Map.GetBitMap(),Map.GetXByte() ,Map.GetYLen());
	GetLayersBase()->ThinAreaN(MAreaMap,TmpMap,Map.GetXByte() ,Map.GetYLen(),10);
	MaskArea.BuildFromRaster(MAreaMap,Map.GetXByte() ,Map.GetYLen() ,0,0);

	DeleteMatrixBuff(MAreaMap,Map.GetYLen());
	DeleteMatrixBuff(TmpMap	 ,Map.GetYLen());

	int	AreaXLen=MaskArea.GetWidth();
	int	AreaYLen=MaskArea.GetHeight();
	SwitchPhaseBase	*ABase=(SwitchPhaseBase *)GetParentBase();

	ImagePointerContainer ImageList;
	GetMasterBuffList(ImageList);

	int	XNumb=AreaXLen/ABase->AutoItemSize;
	int	YNumb=AreaYLen/ABase->AutoItemSize;
	int	PosX=MaskArea.GetMinX();
	int	PosY=MaskArea.GetMinY();

	struct	AreaStruct	*ADim=new struct AreaStruct[XNumb*YNumb];
	int	MinSize=ABase->AutoItemSize*ABase->AutoItemSize*0.3;

	int	XYNumb=XNumb*YNumb;
	#pragma omp parallel                             
	{                                                
		#pragma omp for
		for(int k=0;k<XYNumb;k++){
			int	xn=k%XNumb;
			int	yn=k/XNumb;
			struct	AreaStruct	*AD=&ADim[yn*XNumb+xn];
			AD->Area=new FlexArea();
			*AD->Area=MaskArea;
			AD->Area->ClipArea(PosX+ABase->AutoItemSize*xn	,PosY+ABase->AutoItemSize*yn
							,  PosX+ABase->AutoItemSize*(xn+1),PosY+ABase->AutoItemSize*(yn+1));
			if(AD->Area->GetPatternByte()>=MinSize){
				AD->V=0;
				for(int Layer=0;Layer<GetLayerNumb();Layer++){
					double	Avr	=AD->Area->GetAverage	(*ImageList[Layer],0,0);
					double	V	=AD->Area->GetBunsan	(*ImageList[Layer] ,Avr,0,0);
					if(V>AD->V){
						AD->V=V;
						AD->AdoptedLayer=Layer;
					}
				}
			}
		}
	}

	qsort(ADim,XYNumb,sizeof(ADim[0]),ADimSortFunc1);

	int	N1=XYNumb*0.1;
	if(N1<10)
		N1=XYNumb;
	int	N2=0;
	for(int i=0;i<N1;i++,N2++){
		if(ADim[i].V<=0.0){
			break;
		}
	}

	int	Dm=20;
	#pragma omp parallel                             
	{                                                
		#pragma omp for
		for(int i=0;i<N2;i++){
			struct	AreaStruct	*AD=&ADim[i];
			AD->AreaCoef=new FlexAreaImageListCoeff();
			AD->AreaCoef->Set(*AD->Area,*ImageList[AD->AdoptedLayer]);
			AD->AreaCoef->MakeSum();
			AD->V=0.0;
			for(int dy=-ABase->AutoSearchDot;dy<=ABase->AutoSearchDot;dy++){
				for(int dx=-ABase->AutoSearchDot;dx<=ABase->AutoSearchDot;dx++){
					if(abs(dx)<Dm && abs(dy)<Dm)
						continue;
					double	V	=AD->AreaCoef->CalcCoeff(dx	,dy		,*ImageList[AD->AdoptedLayer]);
					if(V>AD->V){
						AD->V=V;
					}
				}
			}
		}
	}
	qsort(ADim,N2,sizeof(ADim[0]),ADimSortFunc2);

	int	N3=N2/10;
	if(N3<10){
		N3=(N2>10)?10:N2;
	}
	#pragma omp parallel                             
	{                                                
		#pragma omp for
		for(int i=0;i<N3;i++){
			struct	AreaStruct	*AD=&ADim[i];
			AD->V=0.0;
			for(int phase=0;phase<GetPhaseNumb();phase++){
				if(phase==GetPhaseCode())
					continue;
		
				AlgorithmInPageInOnePhase	*Ah=GetParentBase()->GetPageDataPhase(phase);
				SwitchPhaseInPage			*Ap=(SwitchPhaseInPage *)Ah->GetPageData(GetPage());

				ImagePointerContainer PhImageList;
				PageDataInOnePhase	*Ph=GetLayersBase()->GetPageDataPhase(phase);
				DataInPage	*Pg=Ph->GetPageData(GetPage());
				Pg->GetMasterImages(PhImageList);

				for(int dy=-ABase->AutoSearchDot;dy<=ABase->AutoSearchDot;dy++){
					for(int dx=-ABase->AutoSearchDot;dx<=ABase->AutoSearchDot;dx++){
						double	V	=AD->AreaCoef->CalcCoeff(dx	+Ap->MasterShiftX-MasterShiftX
															,dy	+Ap->MasterShiftY-MasterShiftY	
															,*PhImageList[AD->AdoptedLayer]);
						if(V>AD->V){
							AD->V=V;
						}
					}
				}
			}
		}
	}
	qsort(ADim,N3,sizeof(ADim[0]),ADimSortFunc2);

	SwitchPhaseItem	*item=(SwitchPhaseItem *)CreateItem();
	item->SetArea(*ADim[0].Area);
	item->SetManualCreated(false);
	item->GetThresholdW()->SearchDot=ABase->AutoSearchDot;
	AppendItem(item);

	delete	[]ADim;
}

void	SwitchPhaseInPage::UndoSetIndependentItemDataCommand(QIODevice *f)
{
	int	ItemID;
	if(::Load(f,ItemID)==false)
		return;
	AlgorithmItemRoot	*Item=SearchIDItem(ItemID);
	if(Item!=NULL){
		SwitchPhaseItem	*BI=(SwitchPhaseItem *)Item;
		BI->GetThresholdW()->Load(f);
	}
}

//=====================================================================================

SwitchPhaseBase::SwitchPhaseBase(LayersBase *Base)
:AlgorithmBase(Base)
{
	ModeParallelForPhase.ModeParallelExecuteInitialAfterEdit=false;
	ColorSwitchPhase				=Qt::green;
	ColorSelected					=Qt::yellow;
	ColorActive						=Qt::red;
	TransparentLevel				=120;
	NegColorSwitchPhase				=Qt::darkGreen;
	NegColorSelected				=Qt::darkYellow;
	SkipForRoughSearch				=4;
	SourcePhaseInInitial			=0;
	SamePositionAfter2ndPhase		=true;
	Only1MarkInPage					=true;
	AutoItemSize					=50;
	AutoSearchDot					=200;
	ModeCopyAlignment				=true;
	ModeCopyAlgorithmInLoadMaster	=true;
	InspectionCountInPhase			=NULL;

	SetParam(&ColorSwitchPhase		, /**/"Color" ,/**/"ColorSwitchPhase"	,"Color for SwitchPhase area");
	SetParam(&ColorSelected			, /**/"Color" ,/**/"ColorSelected"		,"Color for Selected Piece");
	SetParam(&ColorActive			, /**/"Color" ,/**/"ColorActive"		,"Color for Active Piece");
	SetParam(&TransparentLevel		, /**/"Color" ,/**/"TransparentLevel"	,"Color for Transparent display level");
	SetParam(&NegColorSwitchPhase	, /**/"Color" ,/**/"NegColorSwitchPhase","Color for Negative SwitchPhase area");
	SetParam(&NegColorSelected		, /**/"Color" ,/**/"NegColorSelected"	,"Color for Negative selected SwitchPhase");

	SetParam(&SkipForRoughSearch			, /**/"Setting"	,/**/"SkipForRoughSearch"		,"Skip dot for Rough-search");
	SetParam(&SourcePhaseInInitial			, /**/"Setting"	,/**/"SourcePhaseInInitial"		,"Source phase in ExecuteInitialAfterEdit, -1:No copy");
	SetParam(&SamePositionAfter2ndPhase		, /**/"Setting"	,/**/"SamePositionAfter2ndPhase","Same mark position after 2nd Phase");
	SetParam(&Only1MarkInPage				, /**/"Setting"	,/**/"Only1MarkInPage"			,"Only 1 mark in page");
	SetParam(&ModeCopyAlignment				, /**/"Setting"	,/**/"ModeCopyAlignment"		,"Mode copy Alignment");
	SetParam(&ModeCopyAlgorithmInLoadMaster	, /**/"Setting"	,/**/"ModeCopyAlgorithmInLoadMaster"	,"Mode copy Algorithm in Loading master");

	SetParam(&AutoItemSize			, /**/"Auto"		,/**/"AutoItemSize"			,"Item size for Automatic generation");
	SetParam(&AutoSearchDot			, /**/"Auto"		,/**/"AutoSearchDot"		,"SearchDot for Automatic generation");

	SetParam(&CopiedAlgorithmData, /**/"Setting", /**/"CopiedAlgorithm"		
											 , "Copied Algorithm "		);

	CopiedAlgorithmDim.Add(/**/"Basic",/**/"DotColorMatching");
	//CopiedAlgorithmDim[0].sRoot=/**/"Basic";
	//CopiedAlgorithmDim[0].sName=/**/"ColorDifference";
	//CopiedAlgorithmDim[1].sRoot=/**/"Basic";
	//CopiedAlgorithmDim[1].sName=/**/"AlignmentLarge";
	//CopiedAlgorithmNumb++


}

SwitchPhaseBase::~SwitchPhaseBase(void)
{
	if(InspectionCountInPhase!=NULL){
		delete	[]InspectionCountInPhase;
	}
	InspectionCountInPhase=NULL;
}

AlgorithmDrawAttr	*SwitchPhaseBase::CreateDrawAttr(void)
{
	return new SwitchPhaseDrawAttr();
}

void	SwitchPhaseBase::TransmitDirectly(GUIDirectMessage *packet)
{
	CmdGatherItemResult	*CmdGatherItemResultVar=dynamic_cast<CmdGatherItemResult *>(packet);
	if(CmdGatherItemResultVar!=NULL){
		for(int phase=0;phase<GetPhaseNumb();phase++){
			AlgorithmInPageInOnePhase	*Ph=GetPageDataPhase(phase);
			for(int page=0;page<GetPageNumb();page++){
				Ph->GetPageData(page)->TransmitDirectly(packet);
			}
		}
		return;
	}
	CmdAdjustItemPosition	*CmdAdjustItemPositionVar=dynamic_cast<CmdAdjustItemPosition *>(packet);
	if(CmdAdjustItemPositionVar!=NULL){
		AlgorithmInPageInOnePhase	*DestPh=GetPageDataPhase(CmdAdjustItemPositionVar->TargetPhase);
		for(int page=0;page<GetPageNumb();page++){
			if(DestPh->GetPageData(page)->GetItemCount()>0){
				for(int phase=0;phase<GetPhaseNumb();phase++){
					if(phase!=CmdAdjustItemPositionVar->TargetPhase){
						AlgorithmInPageInOnePhase	*Ph=GetPageDataPhase(phase);
						if(Ph->GetPageData(page)->GetItemCount()>0){
							CmdAdjustItemPositionVar->SourcePhase=phase;
							DestPh->GetPageData(page)->TransmitDirectly(CmdAdjustItemPositionVar);
							goto	NextPage;
						}
					}
				}
			}
NextPage:;
		}
		return;
	}
	CmdAutoGeneration	*CmdAutoGenerationVar=dynamic_cast<CmdAutoGeneration *>(packet);
	if(CmdAutoGenerationVar!=NULL){
		for(int phase=0;phase<GetPhaseNumb();phase++){
			AlgorithmInPageInOnePhase	*Ph=GetPageDataPhase(phase);
			SwitchPhaseInPage	*Pg=dynamic_cast<SwitchPhaseInPage *>(Ph->GetPageData(CmdAutoGenerationVar->LocalPage));
			Pg->GenerateItemAutomaticly();
		}
		return;
	}
	CmdDeleteAllItemInAllPhases	*CmdDeleteAllItemInAllPhasesVar=dynamic_cast<CmdDeleteAllItemInAllPhases *>(packet);
	if(CmdDeleteAllItemInAllPhasesVar!=NULL){
		for(int phase=0;phase<GetPhaseNumb();phase++){
			AlgorithmInPageInOnePhase	*Ph=GetPageDataPhase(phase);
			SwitchPhaseInPage	*Pg=dynamic_cast<SwitchPhaseInPage *>(Ph->GetPageData(CmdDeleteAllItemInAllPhasesVar->LocalPage));
			Pg->RemoveAllDatas();
		}
		return;
	}
}

ExeResult	SwitchPhaseBase::ExecuteInitialAfterEdit(int ExeID 
													,ResultBaseForAlgorithmRoot *Res
													,ExecuteInitialAfterEditInfo &EInfo)
{
	ExeResult	Ret=AlgorithmBase::ExecuteInitialAfterEdit	(ExeID ,Res,EInfo);
	if(InspectionCountInPhase!=NULL){
		delete	[]InspectionCountInPhase;
	}
	InspectionCountInPhase=new int32[GetPhaseNumb()];
	for(int phase=0;phase<GetPhaseNumb();phase++){
		InspectionCountInPhase[phase]=0;
	}
	GetParamGlobal()->UseScanPhaseNumber=false;
	return Ret;
}

ExeResult	SwitchPhaseBase::ExecutePreProcessing	(int ExeID ,ResultBaseForAlgorithmRoot *Res)
{
	DWORD	StartCalcTime=GetComputerMiliSec();

	ExeResult	Ret=_ER_true;
	//Ret=AlgorithmBase::ExecutePreProcessing	(Res ,pInspectionData);
	if(GetPhaseNumb()<2 || GetParamGlobal()->CalcSingleThread==true){
		for(int phase=0;phase<GetPhaseNumb();phase++){
			ResultBasePhase		*Rh=Res->GetPageDataPhase(phase);
			Ret=Rh->ExecutePreProcessing(ExeID ,this);
		}
	}
	else{
		int	N=GetPhaseNumb();
		#pragma omp parallel                             
		{                                                
			#pragma omp for
			for(int phase=0;phase<N;phase++){
				ResultBasePhase		*Rh=Res->GetPageDataPhase(phase);
				if(Rh->ExecutePreProcessing(ExeID ,this)==_ER_false){
					Ret=_ER_false;
				}
			}
		}
	}

	double	MaxD=0;
	int		MaxPhase=0;

	int	ItemCount=0;
	AlgorithmInPageInOnePhase	*Ph=GetPageDataPhase(GetLayersBase()->GetCurrentPhase());
	for(int page=0;page<GetPageNumb();page++){
		SwitchPhaseInPage	*SPage=(SwitchPhaseInPage *)Ph->GetPageData(page);
		ItemCount+=SPage->GetItemCount();
	}
	if(ItemCount!=0){
		for(int phase=0;phase<GetPhaseNumb();phase++){
			AlgorithmInPageInOnePhase	*Ph=GetPageDataPhase(phase);
			if(Ph->GetEnableExecute()==true){
				double	M=1.0;
				for(int page=0;page<GetPageNumb();page++){
					SwitchPhaseInPage	*SPage=(SwitchPhaseInPage *)Ph->GetPageData(page);
					double	D=SPage->GetMatchingRate();
					M*=D;
				}
				if(M>MaxD){
					MaxD=M;
					MaxPhase=phase;
				}
			}
		}
		GetLayersBase()->SetCurrentPhase(MaxPhase);
		int	tmpModeStartByInspection=GetParamGlobal()->ModePhaseExecuteStartByInspection;
		int	tmpModePreAlignment		=GetParamGlobal()->ModePhaseExecutePreAlignment;
		int	tmpModeAlignment		=GetParamGlobal()->ModePhaseExecuteAlignment;

		GetParamGlobal()->ModePhaseExecuteStartByInspection	=MaxPhase;
		GetParamGlobal()->ModePhaseExecutePreAlignment		=MaxPhase;
		GetParamGlobal()->ModePhaseExecuteAlignment			=MaxPhase;
		GetParamGlobal()->ModePhaseExecuteProcessing		=MaxPhase;
		GetParamGlobal()->ModePhaseExecuteProcessingRevived	=MaxPhase;
		GetParamGlobal()->ModePhaseExecutePostProcessing	=MaxPhase;

		if(MaxPhase!=0){
			if(InspectionCountInPhase!=NULL){
				InspectionCountInPhase[MaxPhase]++;
			}
			//int	LastCurrentCalcPoint=GetLayersBase()->GetCurrentCalcPoint();

			//LastCurrentCalcPoint--;
			//if(LastCurrentCalcPoint<0)
			//	LastCurrentCalcPoint=GetParamGlobal()->NGCacheNumb-1;
			//GetLayersBase()->SetProcessDone(false);
			//GetLayersBase()->SetCurrentCalcPoint(LastCurrentCalcPoint);
			//bool	tAllocateTargetTRBuff=GetParamGlobal()->AllocateTargetTRBuff;
			//GetParamGlobal()->AllocateTargetTRBuff=false;
			//GetLayersBase()->ExecuteStartByInspection	(false);
			//GetParamGlobal()->AllocateTargetTRBuff=tAllocateTargetTRBuff;
			//GetLayersBase()->SetCurrentCalcPoint(LastCurrentCalcPoint);

			int	Index=GetLayersBase()->GetIndexInCurrentStateExecuter(DataInExecuter::FinExecutePreProcessing);
			GetLayersBase()->SetProcessDone(false);
			GetLayersBase()->SetCurrentStateInExecuter(Index ,DataInExecuter::FinExecuteStartByInspection);
			GetLayersBase()->ExecutePreAlignment		(false);

			GetLayersBase()->SetProcessDone(false);
			GetLayersBase()->SetCurrentStateInExecuter(Index ,DataInExecuter::FinExecutePreAlignment);
			GetLayersBase()->ExecuteAlignment			(false);
		}
		GetParamGlobal()->ModePhaseExecuteStartByInspection	=tmpModeStartByInspection	;
		GetParamGlobal()->ModePhaseExecutePreAlignment		=tmpModePreAlignment		;
		GetParamGlobal()->ModePhaseExecuteAlignment			=tmpModeAlignment			;
	}
	DWORD	TM=::GetComputerMiliSec()-StartCalcTime;

	return Ret;
}

bool	SwitchPhaseBase::SaveOnlyBase(QIODevice *f)
{
	if(AlgorithmBase::SaveOnlyBase(f)==false)
		return false;
	return true;
}
bool	SwitchPhaseBase::LoadOnlyBase(QIODevice *f)
{
	if(AlgorithmBase::LoadOnlyBase(f)==false)
		return false;
	return true;
}

bool	SwitchPhaseBase::GeneralDataRelease(int32 Command,void *data)
{
	if(Command==SwitchPhaseReqNameReqCommand){
		delete	data;
		return true;
	}
	else if(Command==SwitchPhaseReqNameSendCommand){
		delete	data;
		return true;
	}
	else{
		return AlgorithmBase::GeneralDataRelease(Command,data);
	}
}
void	*SwitchPhaseBase::GeneralDataCreate(int32 Command ,void *reqData)
{
	if(Command==SwitchPhaseReqNameReqCommand){
		return new SwitchPhaseNameReq();
	}
	else if(Command==SwitchPhaseReqNameSendCommand){
		SwitchPhaseNameSend	*pSend=new SwitchPhaseNameSend();
		if(reqData!=NULL){
			SwitchPhaseNameReq	*req=(SwitchPhaseNameReq *)reqData;
			pSend->ConstructList(req,this);
		}
		return pSend;
	}
	else{
		return AlgorithmBase::GeneralDataCreate(Command,reqData);
	}
	return NULL;
}
bool	SwitchPhaseBase::GeneralDataLoad(QIODevice *f,int32 Command,void *data)
{
	if(Command==SwitchPhaseReqNameReqCommand){
		SwitchPhaseNameReq	*p=(SwitchPhaseNameReq *)data;
		return p->Load(f);
	}
	else if(Command==SwitchPhaseReqNameSendCommand){
		SwitchPhaseNameSend	*p=(SwitchPhaseNameSend *)data;
		return p->Load(f);
	}
	else{
		return AlgorithmBase::GeneralDataLoad(f,Command,data);
	}
	return false;
}
bool	SwitchPhaseBase::GeneralDataSave(QIODevice *f,int32 Command,void *data)
{
	if(Command==SwitchPhaseReqNameReqCommand){
		SwitchPhaseNameReq	*p=(SwitchPhaseNameReq *)data;
		return p->Save(f);
	}
	else if(Command==SwitchPhaseReqNameSendCommand){
		SwitchPhaseNameSend	*p=(SwitchPhaseNameSend *)data;
		return p->Save(f);
	}
	else{
		return AlgorithmBase::GeneralDataSave(f,Command,data);
	}
	return false;
}
bool	SwitchPhaseBase::GeneralDataReply(int32 Command,void *data)
{
	if(Command==SwitchPhaseReqNameReqCommand){
		SwitchPhaseNameReq	*p=(SwitchPhaseNameReq *)data;
		return true;
	}
	else if(Command==SwitchPhaseReqNameSendCommand){
		SwitchPhaseNameSend	*p=(SwitchPhaseNameSend *)data;
		return true;
	}
	else{
		return AlgorithmBase::GeneralDataReply(Command,data);
	}
	return false;
}

bool	SwitchPhaseBase::SaveParam(QIODevice *f ,int EnableCondition)
{
	if(AlgorithmBase::SaveParam(f,EnableCondition)==false){
		return false;
	}
	if(CopiedAlgorithmDim.Save(f)==false){
		return false;
	}
	return true;
}
bool	SwitchPhaseBase::LoadParam(QIODevice *f ,int EnableCondition)
{
	if(AlgorithmBase::LoadParam(f,EnableCondition)==false){
		return false;
	}
	if(CopiedAlgorithmDim.Load(f)==false){
		return false;
	}
	return true;
}
bool	SwitchPhaseBase::LoadParam(QIODevice *f ,int StartPoint ,int EndPoint ,int EnableCondition)
{
	if(AlgorithmBase::LoadParam(f,StartPoint,EndPoint,EnableCondition)==false){
		return false;
	}
	if(CopiedAlgorithmDim.Load(f)==false){
		return false;
	}
	return true;
}
void	SwitchPhaseBase::ExecuteForByteArray(const QString &Category ,const QString &KeyName ,QByteArray &data)
{
	SelectAlgorithmListDialog	D(GetLayersBase(),this);
	if(D.exec()==true){
		CopiedAlgorithmDim=D.CopiedAlgorithmDim;
	}
}
QString	SwitchPhaseBase::GetNameByCurrentLanguage(void)
{
	return "PhaseØ‘Öˆ—";
}

SwitchPhaseNameReq::SwitchPhaseNameReq(void)
{
	GlobalPage=-1;
	ItemID=-1;
	Mastered=true;
	Dx=0;
	Dy=0;
}
bool	SwitchPhaseNameReq::Save(QIODevice *f)
{
	if(::Save(f,GlobalPage)==false)
		return false;
	if(::Save(f,ItemID)==false)
		return false;
	if(::Save(f,Mastered)==false)
		return false;
	if(::Save(f,Dx)==false)
		return false;
	if(::Save(f,Dy)==false)
		return false;
	return true;
}
bool	SwitchPhaseNameReq::Load(QIODevice *f)
{
	if(::Load(f,GlobalPage)==false)
		return false;
	if(::Load(f,ItemID)==false)
		return false;
	if(::Load(f,Mastered)==false)
		return false;
	if(::Load(f,Dx)==false)
		return false;
	if(::Load(f,Dy)==false)
		return false;
	return true;
}
SwitchPhaseNameSend::SwitchPhaseNameSend(void)
{
	GlobalPage=-1;
	ItemID=-1;
	Mastered=true;
	Dx=0;
	Dy=0;
}

void	SwitchPhaseNameSend::ConstructList(SwitchPhaseNameReq *reqPacket,SwitchPhaseBase *Base)
{
	GlobalPage	=reqPacket->GlobalPage;
	ItemID		=reqPacket->ItemID;
	Mastered	=reqPacket->Mastered;
	Dx			=reqPacket->Dx;
	Dy			=reqPacket->Dy;
	int	localPage=Base->GetLayersBase()->GetLocalPageFromGlobal(GlobalPage);
	AlgorithmInPagePI	*Ap=dynamic_cast<AlgorithmInPagePI *>(Base->GetPageData(localPage));
	if(Ap!=NULL){
		AlgorithmItemRoot	*item	=Ap->SearchIDItem(ItemID);
		if(item!=NULL){
			SwitchPhaseItem	*BItem=(SwitchPhaseItem *)item;
			AreaName	=BItem->GetItemName();
		}
	}
}

bool	SwitchPhaseNameSend::Save(QIODevice *f)
{
	if(::Save(f,GlobalPage)==false)
		return false;
	if(::Save(f,ItemID)==false)
		return false;
	if(::Save(f,Mastered)==false)
		return false;
	if(::Save(f,Dx)==false)
		return false;
	if(::Save(f,Dy)==false)
		return false;
	if(::Save(f,AreaName)==false)
		return false;
	return true;
}
bool	SwitchPhaseNameSend::Load(QIODevice *f)
{
	if(::Load(f,GlobalPage)==false)
		return false;
	if(::Load(f,ItemID)==false)
		return false;
	if(::Load(f,Mastered)==false)
		return false;
	if(::Load(f,Dx)==false)
		return false;
	if(::Load(f,Dy)==false)
		return false;
	if(::Load(f,AreaName)==false)
		return false;
	return true;
}
