#include "XRaster.h"
#include "XRasterLibrary.h"
#include "XGeneralFunc.h"
#include "swap.h"
#include "XGeneralFunc.h"
#define _USE_MATH_DEFINES
#include <math.h>
#include "XImageProcess.h"

void	RasterInPage::MakeImage(BoolList &ButtonsToOperateLayer
								,QColor LayerColor[MaxRasterLayer])
{
	int	XLen=min(4000,GetDotPerLine());
	int	YLen=min(4000,GetMaxLines());
	int	Overlap=200;
	int	XDir=XLen-2*Overlap;
	int	YDir=YLen-2*Overlap;
	int	XNumb=(GetDotPerLine()+XDir-1)/XDir;
	int	YNumb=(GetMaxLines()+YDir-1)/YDir;
	RasterDrawAttr	Attr;
	int	N=0;
	RasterBase	*GBase=(RasterBase *)GetParentBase();
	for(BoolClass *b=ButtonsToOperateLayer.GetFirst();b!=NULL;b=b->GetNext(),N++){
		if(b->GetValue()==true && FileLayerList[N]!=NULL){
			Attr.ShownFileID.Add(FileLayerList[N]->FileLayerID);
			Attr.LayerColor[N]=LayerColor[N];
		}
	}
	
	int	DotPerLine=GetDotPerLine();
	QImage	TmpImage(XLen,YLen,QImage::Format_ARGB32);
	for(int yn=0;yn<YNumb;yn++){
		for(int xn=0;xn<XNumb;xn++){
			TmpImage.fill(0);

			N=0;
			for(BoolClass *b=ButtonsToOperateLayer.GetFirst();b!=NULL;b=b->GetNext(),N++){
				RasterFileLayer	*F=FileLayerList[N];
				if(b->GetValue()==true && F!=NULL){
					for(AlgorithmItemPI	*a=GetFirstData();a!=NULL;a=a->GetNext()){
						RasterItemAbstract	*Item=dynamic_cast<RasterItemAbstract *>(a);
						if(Item!=NULL){
							if(Item->GetFileLayerID()!=NULL && Item->GetFileLayerID()==F->GetFileLayerID()){
								a->Draw(TmpImage,-xn*XDir+Overlap,-yn*YDir+Overlap,1.0,&Attr);
							}
						}
					}
				}
			}
			int	MasterNoForImaging=GBase->MasterNoForImaging;
			if(MasterNoForImaging<0)
				MasterNoForImaging=0;
			if(MasterNoForImaging>=GetCountAllMasterBuff())
				MasterNoForImaging=GetCountAllMasterBuff();
			DataInPage	*Dp=GetDataInPage();
			ImagePointerContainer Images;
			if(GetLayersBase()->GetParamGlobal()->AllocateMasterBuff==true){
				if(MasterNoForImaging<GetLayersBase()->GetParamGlobal()->AllocatedCountMasterBuff){
					Dp->GetMasterImages(MasterNoForImaging,Images);
				}
				else{
					Dp->GetMasterImages(Images);
				}
			}
			else if(GetLayersBase()->GetParamGlobal()->AllocateTargetBuff==true)
				Dp->GetTargetImages(Images);

			if(GetLayerNumb()>1){
				for(int layer=0;layer<GetLayerNumb();layer++){
					ImageBuffer	*IBuff=Images[layer];
					//#pragma omp parallel
					//{
					//	#pragma omp for
						for(int y=Overlap;y<YLen-Overlap;y++){
							int	Y=y-Overlap+yn*YDir;
							if(Y<GetMaxLines()){
								int	X=xn*XDir;
								QRgb	*s=(QRgb *)TmpImage.scanLine(y);
								BYTE	*d=IBuff->GetY(Y);
								int	NN=min(XLen-Overlap-Overlap,DotPerLine-X);
								int	x=Overlap;
								d=&d[X];
								s=&s[x];
								if(layer==0){
									//for(int x=Overlap;x<XLen-Overlap && X<DotPerLine;x++,X++){
									for(int h=0;h<NN;h++,d++,s++){
										*d=qRed(*s);
									}
								}
								else if(layer==1){
									//for(int x=Overlap;x<XLen-Overlap && X<DotPerLine;x++,X++){
									for(int h=0;h<NN;h++,d++,s++){
										*d=qGreen(*s);
									}
								}
								else if(layer==2){
									//for(int x=Overlap;x<XLen-Overlap && X<DotPerLine;x++,X++){
									for(int h=0;h<NN;h++,d++,s++){
										*d=qBlue(*s);
									}
								}
							}
						}
				}
				//}
			}
			else if(GetLayerNumb()==1){
				ImageBuffer	*IBuff=Images[0];
				//#pragma omp parallel
				//{
				//	#pragma omp for
					for(int y=Overlap;y<YLen-Overlap;y++){
						int	Y=y-Overlap+yn*YDir;
						if(Y<GetMaxLines()){
							int	X=xn*XDir;
							QRgb	*s=(QRgb *)TmpImage.scanLine(y);
							BYTE	*d=IBuff->GetY(Y);
							int	NN=min(XLen-Overlap-Overlap,DotPerLine-X);
							int	x=Overlap;
							d=&d[X];
							s=&s[x];
							//for(int x=Overlap;x<XLen-Overlap && X<DotPerLine;x++,X++){
							for(int h=0;h<NN;h++,d++,s++){
								*d=qGray(*s);
							}
						}
					}
				
				//}
			}
		}
	}
}
void	RasterInPage::MakeImage(void)
{
	RasterMapForMaster.MakeImageBuff(GetLayerNumb() ,ImageBufferOther ,GetDotPerLine() ,GetMaxLines());
	ImagePointerContainer	DestBuff(RasterMapForMaster);
	MakeImage	(DestBuff);

	MasterNo=GetDataInPage()->SetDispatchMaster("Raster", DefLibTypeRaster
								,RasterMapForMaster,MasterNo);
}
void	RasterInPage::MakeImage	(ImagePointerContainer &DestBuff)
{
	int	XLen=min(4000,GetDotPerLine());
	int	YLen=min(4000,GetMaxLines());
	int	OverlapX=(XLen>1000)?200:XLen/20;
	int	OverlapY=(XLen>1000)?200:XLen/20;
	int	XDir=XLen-2*OverlapX;
	int	YDir=YLen-2*OverlapY;
	int	XNumb=(GetDotPerLine()+XDir-1)/XDir;
	int	YNumb=(GetMaxLines()+YDir-1)/YDir;
	RasterBase	*GBase=(RasterBase *)GetParentBase();

	int	LayerNumb=min(GetLayerNumb(),(int)DestBuff.GetCount());
	int	DotPerLine=GetDotPerLine();
	QImage	TmpImage(XLen,YLen,QImage::Format_ARGB32);
	for(int yn=0;yn<YNumb;yn++){
		for(int xn=0;xn<XNumb;xn++){
			TmpImage.fill(0);

			for(AlgorithmItemPI	*a=GetFirstData();a!=NULL;a=a->GetNext()){
				RasterItemAbstract	*Item=dynamic_cast<RasterItemAbstract *>(a);
				if(Item!=NULL){
					a->Draw(TmpImage,-xn*XDir+OverlapX,-yn*YDir+OverlapY,1.0,NULL);
				}
			}

			if(LayerNumb>1){
				for(int layer=0;layer<LayerNumb;layer++){
					ImageBuffer	*IBuff=DestBuff[layer];
					//#pragma omp parallel
					//{
					//	#pragma omp for
						for(int y=OverlapY;y<YLen-OverlapY;y++){
							int	Y=y-OverlapY+yn*YDir;
							if(Y<GetMaxLines()){
								int	X=xn*XDir;
								QRgb	*s=(QRgb *)TmpImage.scanLine(y);
								BYTE	*d=IBuff->GetY(Y);
								int	NN=min(XLen-OverlapX-OverlapX,DotPerLine-X);
								int	x=OverlapX;
								d=&d[X];
								s=&s[x];
								if(layer==0){
									for(int h=0;h<NN;h++,d++,s++){
										*d=qRed(*s);
									}
								}
								else if(layer==1){
									for(int h=0;h<NN;h++,d++,s++){
										*d=qGreen(*s);
									}
								}
								else if(layer==2){
									for(int h=0;h<NN;h++,d++,s++){
										*d=qBlue(*s);
									}
								}
							}
						}
				}
				//}
			}
			else if(LayerNumb==1){
				ImageBuffer	*IBuff=DestBuff[0];
				//#pragma omp parallel
				//{
				//	#pragma omp for
					for(int y=OverlapY;y<YLen-OverlapY;y++){
						int	Y=y-OverlapY+yn*YDir;
						if(Y<GetMaxLines()){
							int	X=xn*XDir;
							QRgb	*s=(QRgb *)TmpImage.scanLine(y);
							BYTE	*d=IBuff->GetY(Y);
							int	NN=min(XLen-OverlapX-OverlapX,DotPerLine-X);
							int	x=OverlapX;
							d=&d[X];
							s=&s[x];
							for(int h=0;h<NN;h++,d++,s++){
								*d=qGray(*s);
							}
						}
					}
				
				//}
			}
		}
	}
}
	
void	RasterInPage::MakeBitImage(BoolList &ButtonsToOperateLayer
								,QColor LayerColor[MaxRasterLayer])
{
	int	XLen=min(4000,GetDotPerLine());
	int	YLen=min(4000,GetMaxLines());
	int	Overlap=200;
	int	XDir=XLen-2*Overlap;
	int	YDir=YLen-2*Overlap;
	int	XNumb=(GetDotPerLine()+XDir-1)/XDir;
	int	YNumb=(GetMaxLines()+YDir-1)/YDir;
	RasterDrawAttr	Attr;
	int	N=0;
	RasterBase	*GBase=(RasterBase *)GetParentBase();
	for(BoolClass *b=ButtonsToOperateLayer.GetFirst();b!=NULL;b=b->GetNext(),N++){
		if(b->GetValue()==true && FileLayerList[N]!=NULL){
			Attr.ShownFileID.Add(FileLayerList[N]->FileLayerID);
			Attr.LayerColor[N]=LayerColor[N];
		}
	}

	DataInPage	*Dp=GetDataInPage();
	ImagePointerContainer Images;
	Dp->GetBitImages(Images);
	QImage	TmpImage(XLen,YLen,QImage::Format_ARGB32);
	for(int layer=0;layer<GetLayerNumb();layer++){
		ImageBuffer	*IBuff=Images[layer];
		IBuff->Memset(0);
	}
	int	DotPerLine=GetDotPerLine();
	for(int yn=0;yn<YNumb;yn++){
		for(int xn=0;xn<XNumb;xn++){
			TmpImage.fill(0);

			N=0;
			for(BoolClass *b=ButtonsToOperateLayer.GetFirst();b!=NULL;b=b->GetNext(),N++){
				RasterFileLayer	*F=FileLayerList[N];
				if(b->GetValue()==true && F!=NULL){
					for(AlgorithmItemPI	*a=GetFirstData();a!=NULL;a=a->GetNext()){
						RasterItemAbstract	*Item=dynamic_cast<RasterItemAbstract *>(a);
						if(Item!=NULL){
							if(Item->GetFileLayerID()!=NULL && Item->GetFileLayerID()==F->GetFileLayerID()){
								a->Draw(TmpImage,-xn*XDir+Overlap,-yn*YDir+Overlap,1.0,&Attr);
							}
						}
					}
				}
			}

			for(int layer=0;layer<GetLayerNumb();layer++){
				ImageBuffer	*IBuff=Images[layer];
				//#pragma omp parallel
				//{
				//	#pragma omp for
					for(int y=Overlap;y<YLen-Overlap;y++){
						int	Y=y-Overlap+yn*YDir;
						if(Y<GetMaxLines()){
							int	X=xn*XDir;
							QRgb	*s=(QRgb *)TmpImage.scanLine(y);
							BYTE	*d=IBuff->GetY(Y);

							int	NN=min(XLen-Overlap-Overlap,DotPerLine-X);
							int	x=Overlap;
							s=&s[x];
							//for(int x=Overlap;x<XLen-Overlap && X<GetDotPerLine();x++,X++){
							for(int h=0;h<NN;h++,X++,s++){
								if(qRed(*s)>=128 || qGreen(*s)>=128 || qBlue(*s)>=128)
									SetBmpBitOnY1(d,X);
							}
						}
					}
				//}
					IBuff->SetChanged(true);
			}
		}
	}
}

void	RasterInPage::MakeImage(BYTE **CurrentBmp,int LayerCompositeID)
{
	RasterBase	*GBase=(RasterBase *)GetParentBase();

	int	XLen=GetDotPerLine();
	int	XByte=(XLen+7)/8;
	int	YLen=GetMaxLines();

	BYTE	**TmpMap	=MakeMatrixBuff(XByte ,YLen);
	BYTE	**TmpImage	=MakeMatrixBuff(XByte ,YLen);

	RasterFileLayer	*F=FileLayerList[LayerCompositeID];
	if(F!=NULL){
		MatrixBuffClear	(TmpImage ,0,XByte ,YLen);
		
		int	KNumb=0;
		for(AlgorithmItemPI	*a=GetFirstData();a!=NULL;a=a->GetNext(),KNumb++){
			RasterItemAbstract	*Item=static_cast<RasterItemAbstract *>(a);
			if(Item!=NULL){
				if(Item->GetFileLayerID()!=NULL && Item->GetFileLayerID()==F->GetFileLayerID()){
					Item->MakeImage(TmpImage,0,0,XByte,YLen);
				}
			}
		}

		MatrixBuffOr	(CurrentBmp,(const BYTE **)TmpImage,XByte ,YLen);
	}
	DeleteMatrixBuff(TmpImage ,YLen);
	DeleteMatrixBuff(TmpMap,YLen);
}

void	RasterInPage::MakeImageEnlarge(BYTE **CurrentBmp
										,int LayerCompositeID )
{
	RasterBase	*GBase=(RasterBase *)GetParentBase();

	int	XLen=GetDotPerLine();
	int	XByte=(XLen+7)/8;
	int	YLen=GetMaxLines();

	BYTE	**TmpImage	=MakeMatrixBuff(XByte ,YLen);
	BYTE	**TmpImage2	=MakeMatrixBuff(XByte ,YLen);
	MatrixBuffClear	(TmpImage ,0,XByte ,YLen);

	AlgorithmLibraryContainer	*Container=GetLibraryContainer();

	RasterFileLayer	*F=FileLayerList[LayerCompositeID];
	if(F!=NULL){
		AlgorithmLibraryLevelContainer	LLib(Container);
		if(Container->GetLibrary(F->LibID,LLib)==true){
			RasterLibrary	*ALib=dynamic_cast<RasterLibrary *>(LLib.GetLibrary());
			MatrixBuffClear	(TmpImage ,0,XByte ,YLen);
			for(AlgorithmItemPI	*a=GetFirstData();a!=NULL;a=a->GetNext()){
				RasterItemAbstract	*Item=dynamic_cast<RasterItemAbstract *>(a);
				if(Item!=NULL){
					if(Item->GetFileLayerID()!=NULL && Item->GetFileLayerID()==F->GetFileLayerID()){
						Item->MakeImage(TmpImage,0,0,XByte,YLen);
					}
				}
			}
			MatrixBuffOr	(CurrentBmp,(const BYTE **)TmpImage,XByte ,YLen);
		}
	}
	DeleteMatrixBuff(TmpImage ,YLen);
	DeleteMatrixBuff(TmpImage2,YLen);
}

void	RasterInPage::MakeImageShiftable(BYTE **CurrentBmp
										,int LayerCompositeID)
{
	RasterBase	*GBase=(RasterBase *)GetParentBase();

	int	XLen=GetDotPerLine();
	int	XByte=(XLen+7)/8;
	int	YLen=GetMaxLines();
	BYTE	**TmpImage	=MakeMatrixBuff(XByte ,YLen);
	BYTE	**TmpImage2	=MakeMatrixBuff(XByte ,YLen);

	AlgorithmLibraryContainer	*Container=GetLibraryContainer();

	RasterFileLayer	*F=FileLayerList[LayerCompositeID];
	if(F!=NULL){
		AlgorithmLibraryLevelContainer	LLib(Container);
		if(Container->GetLibrary(F->LibID,LLib)==true){
			RasterLibrary	*ALib=dynamic_cast<RasterLibrary *>(LLib.GetLibrary());
			MatrixBuffClear	(TmpImage ,0,XByte ,YLen);
			for(AlgorithmItemPI	*a=GetFirstData();a!=NULL;a=a->GetNext()){
				RasterItemAbstract	*Item=dynamic_cast<RasterItemAbstract *>(a);
				if(Item!=NULL){
					if(Item->GetFileLayerID()!=NULL && Item->GetFileLayerID()==F->GetFileLayerID()){
						Item->MakeImage(TmpImage,0,0,XByte,YLen);
					}
				}
			}

			GetLayersBase()->FatAreaN(TmpImage ,TmpImage2,XByte,YLen
					,ALib->MaxShiftDot);
			MatrixBuffOr	(CurrentBmp,(const BYTE **)TmpImage,XByte ,YLen);
		}

		if(Container->GetLibrary(F->LibID,LLib)==true){
			RasterLibrary	*ALib=dynamic_cast<RasterLibrary *>(LLib.GetLibrary());
			MatrixBuffClear	(TmpImage ,0,XByte ,YLen);
			for(AlgorithmItemPI	*a=GetFirstData();a!=NULL;a=a->GetNext()){
				RasterItemAbstract	*Item=dynamic_cast<RasterItemAbstract *>(a);
				if(Item!=NULL){
					if(Item->GetFileLayerID()!=NULL && Item->GetFileLayerID()==F->GetFileLayerID()){
						Item->MakeImage(TmpImage,0,0,XByte,YLen);
					}
				}
			}
			MatrixBuffNotAnd(CurrentBmp,(const BYTE **)TmpImage,XByte ,YLen);
		}
	}
	
	DeleteMatrixBuff(TmpImage,YLen);
	DeleteMatrixBuff(TmpImage2,YLen);
}

void	RasterInPage::MakeImageShrinked(BYTE **CurrentBmp
										,int LayerCompositeID )
{
	RasterBase	*GBase=(RasterBase *)GetParentBase();

	int	XLen=GetDotPerLine();
	int	XByte=(XLen+7)/8;
	int	YLen=GetMaxLines();
	BYTE	**TmpImage =MakeMatrixBuff(XByte ,YLen);
	BYTE	**TmpImage2=MakeMatrixBuff(XByte ,YLen);

	AlgorithmLibraryContainer	*Container=GetLibraryContainer();

	RasterFileLayer	*F=FileLayerList[LayerCompositeID];
	if(F!=NULL){
		AlgorithmLibraryLevelContainer	LLib(Container);
		if(Container->GetLibrary(F->LibID,LLib)==true){
			RasterLibrary	*ALib=dynamic_cast<RasterLibrary *>(LLib.GetLibrary());
			MatrixBuffClear	(TmpImage ,0,XByte ,YLen);
			for(AlgorithmItemPI	*a=GetFirstData();a!=NULL;a=a->GetNext()){
				RasterItemAbstract	*Item=dynamic_cast<RasterItemAbstract *>(a);
				if(Item!=NULL){
					if(Item->GetFileLayerID()!=NULL && Item->GetFileLayerID()==F->GetFileLayerID()){
						Item->MakeImage(TmpImage,0,0,XByte,YLen);
					}
				}
			}
			MatrixBuffOr(CurrentBmp,(const BYTE **)TmpImage,XByte ,YLen);
		}

		if(Container->GetLibrary(F->LibID,LLib)==true){
			RasterLibrary	*ALib=dynamic_cast<RasterLibrary *>(LLib.GetLibrary());
			MatrixBuffClear	(TmpImage ,0,XByte ,YLen);
			for(AlgorithmItemPI	*a=GetFirstData();a!=NULL;a=a->GetNext()){
				RasterItemAbstract	*Item=dynamic_cast<RasterItemAbstract *>(a);
				if(Item!=NULL){
					if(Item->GetFileLayerID()!=NULL && Item->GetFileLayerID()==F->GetFileLayerID()){
						Item->MakeImage(TmpImage,0,0,XByte,YLen);
					}
				}
			}
			GetLayersBase()->FatAreaN(TmpImage ,TmpImage2,XByte,YLen
					,ALib->MaxShrinkDot);
			MatrixBuffAnd	(CurrentBmp,(const BYTE **)TmpImage,XByte ,YLen);
		}
	}
	DeleteMatrixBuff(TmpImage,YLen);
	DeleteMatrixBuff(TmpImage2,YLen);
}
